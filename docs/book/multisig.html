<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Multisig - LWK Documentation</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="styles.css">


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">LWK Documentation</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/blockstream/lwk" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        <a href="https://github.com/blockstream/lwk/edit/master/docs/src/src/multisig.md" title="Suggest an edit" aria-label="Suggest an edit" rel="edit">
                            <i id="git-edit-button" class="fa fa-edit"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="liquid-multisig"><a class="header" href="#liquid-multisig">Liquid Multisig</a></h1>
<p>Liquid has a very similar scripting model with respect to Bitcoin.
It allows to create complex spending conditions for your wallets.</p>
<p>A relatively simple, yet powerful, example is <strong>multisig</strong>.
In a multisig wallet you need <em>n</em> signatures from a set of <em>m</em> public keys to spend a wallet UTXO.</p>
<p>In this guide we will explain how to setup and operate a Liquid Multisig wallet.</p>
<h2 id="setup"><a class="header" href="#setup">Setup</a></h2>
<p>We want to create a <em>2of3</em> between Alice, Bob and Carol.</p>
<p>First each multisig participant creates their signer.
Then they get their <em>xpub</em>, and share it with the coordinator, in this case Carol.
Carol uses the xpubs to construct the multisig CT descriptor.
Finally Carol shares the multisig CT descriptor with Alice and Bob.</p>
<pre class="mermaid">sequenceDiagram
    participant A as Alice
    participant B as Bob
    participant C as Carol&lt;br&gt;(coordinator)
    Note over A: signer A 🔑
    Note over B: signer B 🔑
    Note over C: signer C 🔑
    A-&gt;&gt;C: xpub A
    B-&gt;&gt;C: xpub B
    C-&gt;&gt;C: xpub C
    Note over C: Create&lt;br&gt;CT descriptor👀
    C-&gt;&gt;B: CT descriptor👀
    C-&gt;&gt;A: CT descriptor👀
</pre>
<div class="warning">
⚠️ It's important that all participants in a multisig know the CT descriptors, as it is necessary to validate if addresses and (U)TXO belong to the wallet.
</div>
<custom-tabs category="lang">
<div slot="title">Rust</div>
<section>
<pre><code class="language-rust ignore">let is_mainnet = false;
// Derivation for multisig
let bip = lwk_common::Bip::Bip87;

// Alice creates their signer and gets the xpub
let mnemonic_a = Mnemonic::generate(12)?;
let signer_a = SwSigner::new(&amp;mnemonic_a.to_string(), is_mainnet)?;
let xpub_a = signer_a.keyorigin_xpub(bip, is_mainnet)?;

// Bob creates their signer and gets the xpub
let mnemonic_b = Mnemonic::generate(12)?;
let signer_b = SwSigner::new(&amp;mnemonic_b.to_string(), is_mainnet)?;
let xpub_b = signer_b.keyorigin_xpub(bip, is_mainnet)?;

// Carol, who acts as a coordinator, creates their signer and gets the xpub
let mnemonic_c = Mnemonic::generate(12)?;
let signer_c = SwSigner::new(&amp;mnemonic_c.to_string(), is_mainnet)?;
let xpub_c = signer_c.keyorigin_xpub(bip, is_mainnet)?;

// Carol generates a random SLIP77 descriptor blinding key
let mut slip77_rand_key = [0u8; 32];
use rand::{thread_rng, Rng};
thread_rng().fill(&amp;mut slip77_rand_key);
let slip77_rand_key = slip77_rand_key.to_hex();
let desc_blinding_key = format!("slip77({slip77_rand_key})");

// Carol uses the collected xpubs and the descriptor blinding key to create
// the 2of3 descriptor
let threshold = 2;
let desc = format!("ct({desc_blinding_key},elwsh(multi({threshold},{xpub_a}/&lt;0;1&gt;/*,{xpub_b}/&lt;0;1&gt;/*,{xpub_c}/&lt;0;1&gt;/*)))");
// Validate the descriptor string
let wd = WolletDescriptor::from_str(&amp;desc)?;</code></pre>
</section>
<div slot="title">Python</div>
<section>
<pre><code class="language-python">network = Network.testnet()
# Derivation for multisig
bip = Bip.new_bip87()

# Alice creates their signer and gets the xpub
signer_a = Signer.random(network)
xpub_a = signer_a.keyorigin_xpub(bip);

# Bob creates their signer and gets the xpub
signer_b = Signer.random(network)
xpub_b = signer_b.keyorigin_xpub(bip);

# Carol, who acts as a coordinator, creates their signer and gets the xpub
signer_c = Signer.random(network)
xpub_c = signer_c.keyorigin_xpub(bip);

# Carol generates a random SLIP77 descriptor blinding key
import os
slip77_rand_key = os.urandom(32).hex()
desc_blinding_key = f"slip77({slip77_rand_key})"

# Carol uses the collected xpubs and the descriptor blinding key to create
# the 2of3 descriptor
threshold = 2;
desc = f"ct({desc_blinding_key},elwsh(multi({threshold},{xpub_a}/&lt;0;1&gt;/*,{xpub_b}/&lt;0;1&gt;/*,{xpub_c}/&lt;0;1&gt;/*)))"
# Validate the descriptor string
wd = WolletDescriptor(desc)
</code></pre>
</section>
<div slot="title">Javascript</div>
<section>
<pre><code class="language-typescript">const network = lwk.Network.testnet();
// Derivation for multisig
const bip = lwk.Bip.bip87();

// Alice creates their signer and gets the xpub
const mnemonic_a = lwk.Mnemonic.fromRandom(12);
const signer_a = new lwk.Signer(mnemonic_a, network);
const xpub_a = signer_a.keyoriginXpub(bip);

// Bob creates their signer and gets the xpub
const mnemonic_b = lwk.Mnemonic.fromRandom(12);
const signer_b = new lwk.Signer(mnemonic_b, network);
const xpub_b = signer_b.keyoriginXpub(bip);

// Carol, who acts as a coordinator, creates their signer and gets the xpub
const mnemonic_c = lwk.Mnemonic.fromRandom(12);
const signer_c = new lwk.Signer(mnemonic_c, network);
const xpub_c = signer_c.keyoriginXpub(bip);

// Carol generates a random SLIP77 descriptor blinding key
const slip77_rand_key = "&lt;random-64-hex-chars&gt;";
const desc_blinding_key = `slip77(${slip77_rand_key})`;

// Carol uses the collected xpubs and the descriptor blinding key to create
// the 2of3 descriptor
const threshold = 2;
const desc = `ct(${desc_blinding_key},elwsh(multi(${threshold},${xpub_a}/&lt;0;1&gt;/*,${xpub_b}/&lt;0;1&gt;/*,${xpub_c}/&lt;0;1&gt;/*)))`;
// Validate the descriptor string
const wd = new lwk.WolletDescriptor(desc);
</code></pre>
</section>
</custom-tabs>
<p>In this example Carol creates the SLIP77 key at random, however this is not mandatory and valid alternatives are:</p>
<ul>
<li>"elip151", to deterministically derive the descriptor blinding key from the "bitcoin" descriptor;</li>
<li>derive a SLIP77 deterministic key from a signer, however this descriptor blinding key might be re used in other descriptors.</li>
</ul>
<h2 id="receive-and-monitor"><a class="header" href="#receive-and-monitor">Receive and monitor</a></h2>
<p>The Liquid Multisig wallet is identified by the CT descriptor created during setup.
The descriptor encodes all the information needed to derive scriptpubkeys and blinding keys which are necessary to operate the wallet. In general, it also contains the xpubs <em>key origin</em>, information needed to by signers to sign, consisting in the signer fingerprint and derivation paths.</p>
<p>With the wallet CT descriptor you can:</p>
<ul>
<li>Generate wallet (confidential) addresses</li>
<li>Get the (unblinded) list of the wallet transactions</li>
<li>Get the wallet balance</li>
</ul>
<custom-tabs category="lang">
<div slot="title">Rust</div>
<section>
<pre><code class="language-rust ignore">// Carol creates the wollet
let network = ElementsNetwork::LiquidTestnet;
let mut wollet_c = Wollet::without_persist(network, wd)?;

// With the wollet, Carol can obtain addresses, transactions and balance
let addr = wollet_c.address(None)?;
let txs = wollet_c.transactions()?;
let balance = wollet_c.balance()?;

// Update the wollet state
let url = "https://blockstream.info/liquidtestnet/api";
let mut client = EsploraClient::new(&amp;url, network)?;

if let Some(update) = client.full_scan(&amp;wollet_c)? {
    wollet_c.apply_update(update)?;
}</code></pre>
</section>
<div slot="title">Python</div>
<section>
<pre><code class="language-python"># Carol creates the wollet
wollet_c = Wollet(network, wd, datadir=None)

# With the wollet, Carol can obtain addresses, transactions and balance
addr = wollet_c.address(None);
txs = wollet_c.transactions();
balance = wollet_c.balance();

# Update the wollet state
url = "https://blockstream.info/liquidtestnet/api"
client = EsploraClient(url, network)

update = client.full_scan(wollet_c)
wollet_c.apply_update(update)
</code></pre>
</section>
<div slot="title">Javascript</div>
<section>
<pre><code class="language-typescript">// Carol creates the wollet
const wollet_c = new lwk.Wollet(network, wd);

// With the wollet, Carol can obtain addresses, transactions and balance
const addr = wollet_c.address(null).address().toString();
const txs = wollet_c.transactions();
const balance = wollet_c.balance();

// Update the wollet state
const url = "https://waterfalls.liquidwebwallet.org/liquidtestnet/api";
const client = new lwk.EsploraClient(network, url, true, 4, false);

const update = await client.fullScan(wollet_c);
if (update) {
    wollet_c.applyUpdate(update);
}
</code></pre>
</section>
</custom-tabs>
<p>Note that for generating addresses, getting transactions and balance, you have the same procedure for both singlesig and multisig wallets.</p>
<h2 id="send"><a class="header" href="#send">Send</a></h2>
<p>As for addresses, transactions and balance, to create a multisig transaction you only need the CT descriptor.
In this example Carol creates the transaction.
Since she created the transaction, she's comfortable in skipping validation and she also signs it.
However the wallet is a 2of3, so it needs either Alice or Bob to fully sign the transaction.
Carol sends the transaction (in PSET format) to Bob.
Bob examines the PSET and checks that it does what it's supposed to do (e.g. outgoing addresses, assets, amounts and fees), then it signs the PSET and sends it back to Carol.
The PSET is now fully signed, Carol can finalize it and broadcast the transaction.</p>
<pre class="mermaid">sequenceDiagram
    participant A as Alice
    participant B as Bob
    participant C as Carol&lt;br&gt;(coordinator)
    Note over C: Create PSET&lt;br&gt;(using CT descriptor👀)
    Note over C: signer C 🔑 signs PSET
    C-&gt;&gt;B: PSET
    Note over B: Analyze PSET&lt;br&gt;(using CT descriptor👀)
    Note over B: signer B 🔑 signs PSET
    B-&gt;&gt;C: PSET
    Note over C: Finalize PSET and&lt;br&gt;extract TX
    Note over C: Broadcast TX
</pre>
<custom-tabs category="lang">
<div slot="title">Rust</div>
<section>
<pre><code class="language-rust ignore">// Carol creates a transaction send few sats to a certain address
let address = "&lt;address&gt;";
let sats = 1000;
let lbtc = network.policy_asset();

let mut pset = wollet_c
    .tx_builder()
    .add_recipient(&amp;address, sats, lbtc)?
    .finish()?;

// Carol signs the transaction
let sigs_added = signer_c.sign(&amp;mut pset)?;
assert_eq!(sigs_added, 1);

// Carol sends the PSET to Bob
// Bob wants to analyze the PSET before signing, thus he creates a wollet
let wd = WolletDescriptor::from_str(&amp;desc)?;
let mut wollet_b = Wollet::without_persist(network, wd)?;
if let Some(update) = client.full_scan(&amp;wollet_b)? {
    wollet_b.apply_update(update)?;
}
// Then Bob uses the wollet to analyze the PSET
let details = wollet_b.get_details(&amp;pset)?;
// PSET has a reasonable fee
assert!(details.balance.fee &lt; 100);
// PSET has a signature from Carol
let fingerprints_has = details.fingerprints_has();
assert_eq!(fingerprints_has.len(), 1);
assert!(fingerprints_has.contains(&amp;signer_c.fingerprint()));
// PSET needs a signature from either Bob or Carol
let fingerprints_missing = details.fingerprints_missing();
assert_eq!(fingerprints_missing.len(), 2);
assert!(fingerprints_missing.contains(&amp;signer_a.fingerprint()));
assert!(fingerprints_missing.contains(&amp;signer_b.fingerprint()));
// PSET has a single recipient, with data matching what was specified above
assert_eq!(details.balance.recipients.len(), 1);
let recipient = details.balance.recipients[0].clone();
assert_eq!(recipient.address.unwrap(), address);
assert_eq!(recipient.asset.unwrap(), lbtc);
assert_eq!(recipient.value.unwrap(), sats);

// Bob is satisified with the PSET and signs it
let sigs_added = signer_b.sign(&amp;mut pset)?;
assert_eq!(sigs_added, 1);

// Bob sends the PSET back to Carol
// Carol checks that the PSET has enough signatures
let details = wollet_c.get_details(&amp;pset)?;
assert_eq!(details.fingerprints_has().len(), 2);

// Carol finalizes the PSET and broadcast the transaction
let tx = wollet_c.finalize(&amp;mut pset)?;
let txid = client.broadcast(&amp;tx)?;</code></pre>
</section>
<div slot="title">Python</div>
<section>
<pre><code class="language-python"># Carol creates a transaction send few sats to a certain address
address = "&lt;address&gt;"
sats = 1000
lbtc = network.policy_asset()

b = network.tx_builder()
b.add_recipient(address, sats, lbtc)
pset = b.finish(wollet_c)

pset = signer_c.sign(pset)

# Carol sends the PSET to Bob
# Bob wants to analyze the PSET before signing, thus he creates a wollet
wd = WolletDescriptor(desc)
wollet_b = Wollet(network, wd, datadir=None)
update = client.full_scan(wollet_b)
wollet_b.apply_update(update)
# Then Bob uses the wollet to analyze the PSET
details = wollet_b.pset_details(pset)
# PSET has a reasonable fee
assert details.balance().fee() &lt; 100
# PSET has a signature from Carol
fingerprints_has = details.fingerprints_has()
assert len(fingerprints_has) == 1
assert signer_c.fingerprint() in fingerprints_has
# PSET needs a signature from either Bob or Carol
fingerprints_missing = details.fingerprints_missing()
assert len(fingerprints_missing) == 2
assert signer_a.fingerprint() in fingerprints_missing
assert signer_b.fingerprint() in fingerprints_missing
# PSET has a single recipient, with data matching what was specified above
assert len(details.balance().recipients()) == 1
recipient = details.balance().recipients()[0]
assert str(recipient.address()) == str(address)
assert recipient.asset() == lbtc
assert recipient.value() == sats

# Bob is satisified with the PSET and signs it
pset = signer_b.sign(pset)

# Bob sends the PSET back to Carol
# Carol checks that the PSET has enough signatures
details = wollet_c.pset_details(pset)
fingerprints_has = details.fingerprints_has()
assert len(fingerprints_has) == 2

# Carol finalizes the PSET and broadcast the transaction
tx = pset.finalize()
txid = client.broadcast(tx)
</code></pre>
</section>
<div slot="title">Javascript</div>
<section>
<pre><code class="language-typescript">// Carol creates a transaction send few sats to a certain address
const sats = BigInt(1000);
const address = new lwk.Address("&lt;address&gt;");
const asset = new lwk.AssetId("&lt;asset&gt;");

var builder = new lwk.TxBuilder(network)
builder = builder.addRecipient(address, sats, asset)
var pset = builder.finish(wollet_c)

pset = signer_c.sign(pset)

// Carol sends the PSET to Bob
// Bob wants to analyze the PSET before signing, thus he creates a wollet
const wd_b = new lwk.WolletDescriptor(desc);
const wollet_b = new lwk.Wollet(network, wd_b);
const update_b = await client.fullScan(wollet_b);
if (update_b) {
    wollet_b.applyUpdate(update_b);
}
// Then Bob uses the wollet to analyze the PSET
const details = wollet_b.psetDetails(pset);
// PSET has a reasonable fee
console.assert(details.balance().fee() &lt; 100);
// PSET has a signature from Carol
console.assert(details.fingerprintsHas().length === 1);
console.assert(details.fingerprintsHas().includes(signer_c.fingerprint()));
// PSET needs a signature from either Bob or Carol
console.assert(details.fingerprintsMissing().length === 2);
console.assert(details.fingerprintsMissing().includes(signer_a.fingerprint()));
console.assert(details.fingerprintsMissing().includes(signer_b.fingerprint()));
// PSET has a single recipient, with data matching what was specified above
console.assert(details.balance().recipients().length === 1);
const recipient = details.balance().recipients()[0];
console.assert(recipient.address().toString() === address.toString());
console.assert(recipient.asset().toString() === asset.toString());
console.assert(recipient.value() === sats);

// Bob is satisified with the PSET and signs it
pset = signer_b.sign(pset)

// Bob sends the PSET back to Carol
// Carol checks that the PSET has enough signatures
const details_b = wollet_b.psetDetails(pset);
console.assert(details_b.fingerprintsHas().length === 2);

// Carol finalizes the PSET and broadcast the transaction
pset = wollet_c.finalize(pset)
const tx = pset.extractTx();
const txid = await client.broadcastTx(tx);
</code></pre>
</section>
</custom-tabs>
<div class="warning">
⚠️ Bob needs the CT descriptor to obtain the PSET details, in particular the net balance with respect to the wallet, i.e. how much is being sent out of the wallet.
</div>
<p>In this example we went through an example where the coordinator is one of the multisig participants and the PSET is signed serially. In general, this is not the case.
The coordinator can be a utility service, as long as it knows the multisig CT descriptor.
Also the PSET can be signed in parallel, and in this case the coordinator must combine the signed PSET using <code>Wollet::combine()</code>.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="broadcast.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="amp0.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="broadcast.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="amp0.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="mermaid.min.js"></script>
        <script src="mermaid-init.js"></script>
        <script src="tabs.js"></script>



    </div>
    </body>
</html>
