<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>LWK Documentation</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="styles.css">


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">LWK Documentation</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/blockstream/lwk" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="about-lwk"><a class="header" href="#about-lwk">About LWK</a></h1>
<p>The Liquid Wallet Kit (LWK) is a comprehensive toolkit that empowers developers to build a new generation of wallets and applications for the Liquid Network. Instead of grappling with the intricate, low-level details of Liquid's confidential transactions, asset management, and cryptographic primitives, LWK provides a powerful set of foundational building blocks. These tools are functional and secure, helping you build your projects with confidence.</p>
<p>LWK's primary goal is to abstract away complexity by handling the most challenging aspects of Liquid development, such as:</p>
<ul>
<li><strong>Confidential Transactions</strong> handling, which automatically obscures amounts and asset types to maintain user privacy.</li>
<li><strong>Asset issuance and management</strong>, providing a seamless way to create and interact with new digital assets.</li>
<li><strong>Signing Liquid transactions</strong>, allowing for interaction with software signers and hardware wallets.</li>
</ul>
<p>By providing these building blocks, LWK liberates developers from building Liquid functionality from scratch. This allows them to significantly accelerate development time and focus on creating unique, value-added features for their specific use cases, whether it's building a mobile wallet, integrating Liquid in an exchange, or developing a DeFi application. Ultimately, LWK is the definitive, go-to library for anyone committed to innovating on the Liquid Network.</p>
<h2 id="example-single-sig-mobile-wallet"><a class="header" href="#example-single-sig-mobile-wallet">Example: single-sig mobile wallet</a></h2>
<p>This example application showcases how the Liquid Wallet Kit (LWK) simplifies the development of a single-signature mobile wallet. The two diagrams below illustrate the key user flows: Wallet Creation and Transaction Management. LWK handles the complex, low-level interactions with the Liquid blockchain and cryptographic operations, allowing the application to focus on the user interface and experience.</p>
<h3 id="wallet-creation"><a class="header" href="#wallet-creation">Wallet Creation</a></h3>
<p>The mobile app starts by creating a new software <code>signer</code> and helps the user back up the corresponding BIP39 mnemonic. From this signer, the app extracts the <code>xpub</code> to derive a single-signature <a href="https://github.com/ElementsProject/ELIPs/blob/main/elip-0150.mediawiki">CT descriptor</a> (e.g., <code>ct(slip77(...),elwpkh([...]xpub/&lt;0;1&gt;/*))</code>).</p>
<p>This CT descriptor is then used to initialize a <code>wollet</code>, which is LWK's watch-only wallet. The <code>wollet</code> allows the app to fetch addresses, transactions, and the current balance to display in the user interface.</p>
<p>When the app is opened, it uses a <code>client</code> to sync the wollet with the latest blockchain information. This ensures the wallet data is up-to-date.</p>
<pre class="mermaid">flowchart TD
    Signer(Signer 🔑)
    Wollet(&quot;Wollet 👀&lt;br&gt;(descriptor)&quot;)
    Client(Client 🌐)
    App((📱))
    Signer --&gt;|Xpub| Wollet 
    Client --&gt;|Blockchain Update| Wollet
    Wollet --&gt;|Addresses, Txs, Balance| App
</pre>
<h3 id="transaction-management"><a class="header" href="#transaction-management">Transaction Management</a></h3>
<p>The mobile app enables users to send funds by allowing them to specify the amount, asset, and destination address. The <code>wollet</code> then takes this information to create an unsigned transaction, which is encoded in the <a href="https://github.com/ElementsProject/ELIPs/blob/main/elip-0150.mediawiki">PSET</a> format.</p>
<p>The PSET is passed to the <code>signer</code>, which uses its private keys to sign the transaction. Once the PSET is signed, it's finalized into a complete transaction, which the <code>client</code> then broadcasts to the Liquid Network.</p>
<pre class="mermaid">flowchart TD
    Signer(Signer 🔑)
    Wollet(&quot;Wollet 👀&lt;br&gt;(descriptor)&quot;)
    Client(Client 🌐)
    App((📱))
    App --&gt;|Create TX| Wollet
    Wollet --&gt;|Unsigned PSET| Signer 
    Signer --&gt;|Signed PSET| Wollet 
    Wollet --&gt;|Broadcast TX| Client
</pre>
<h3 id="remarks"><a class="header" href="#remarks">Remarks</a></h3>
<p>This simple example highlights the core responsibilities of each LWK component:</p>
<ul>
<li><strong>Signer</strong> 🔑: Manages private keys and handles all signing operations.</li>
<li><strong>Wollet</strong> 👀: Provides a watch-only view of the wallet, deriving addresses and tracking transactions and balances without holding any private keys.</li>
<li><strong>Client</strong> 🌐: Fetch blockchain data from the Liquid Network to update the <code>wollet</code>.</li>
</ul>
<h2 id="key-features"><a class="header" href="#key-features">Key Features</a></h2>
<p>LWK allows to build more complex applications and prodcuts by leveraging its wide range of features:</p>
<ul>
<li><input disabled="" type="checkbox" checked=""/>
Send and receive LBTC</li>
<li><input disabled="" type="checkbox" checked=""/>
Send and receive Liquid Issued Assets (e.g. USDT)</li>
<li><input disabled="" type="checkbox" checked=""/>
Send and receive AMP assets (e.g. BMN)</li>
<li><input disabled="" type="checkbox" checked=""/>
Software signers</li>
<li><input disabled="" type="checkbox" checked=""/>
Hardware wallets support (Jade)</li>
<li><input disabled="" type="checkbox" checked=""/>
Watch-Only view with CT descriptors</li>
<li><input disabled="" type="checkbox" checked=""/>
Single-sig</li>
<li><input disabled="" type="checkbox" checked=""/>
Generic Multisig</li>
<li><input disabled="" type="checkbox" checked=""/>
Multi-language support (Swift, Kotlin, Javascript, Typescript, Wasm, React Native, Go, C#, Rust, Flutter/Dart, Python)</li>
</ul>
<p>For a more complete and detailed list of LWK features see <a href="features.html">here</a>.</p>
<h2 id="get-started"><a class="header" href="#get-started">Get started</a></h2>
<p><a href="install.html">Install LWK</a> and go through our <a href="basics.html">tutorial</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="features"><a class="header" href="#features">Features</a></h1>
<ul>
<li><strong>Watch-Only</strong> wallet support: using Liquid descriptors, better known as
<a href="https://github.com/ElementsProject/ELIPs/blob/main/elip-0150.mediawiki">CT descriptors</a>.</li>
<li><strong>PSET</strong> based: transactions are shared and processed using the
<a href="https://github.com/ElementsProject/elements/blob/1fcf0cf2323b7feaff5d1fc4c506fff5ec09132e/doc/pset.mediawiki">Partially Signed Elements Transaction</a> format.</li>
<li><a href="https://github.com/Blockstream/electrs"><strong>Electrum</strong>, <strong>Esplora</strong></a> and <a href="https://github.com/RCasatta/waterfalls">Waterfalls</a>:
no need to run and sync a full Liquid node or rely on closed source servers.</li>
<li><strong>Asset issuance</strong>, <strong>reissuance</strong> and <strong>burn</strong> support: manage the lifecycle
of your Issued Assets with a lightweight client.</li>
<li><strong>Generic multisig</strong> wallets: create a wallet controlled by
any combination of hardware or software signers, with a user
specified quorum.</li>
<li><strong>Hardware signer</strong> support: receive, issue, reissue and burn L-BTC and
Issued Assets with your hardware signer, using singlesig or multisig
wallets (currently <a href="https://blockstream.com/jade/"><strong>Jade</strong></a> only, with more coming soon).</li>
<li><strong>Multi Language</strong> support: Swift, Kotlin, Javascript, Typescript, WASM, React Native, Go, C#, Rust, Flutter/Dart and Python.</li>
<li><strong>Liquid Atomic Swaps</strong>: using <a href="https://blog.blockstream.com/liquidex-2-step-atomic-swaps-on-the-liquid-network/">LiquiDEX</a>.</li>
<li><strong>Blockstream AMP</strong> support: send and receive asset issued with the <a href="https://blockstream.com/amp/">Blockstream Asset Management Platform</a>.</li>
<li><strong>...and more!</strong></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="installing-lwk"><a class="header" href="#installing-lwk">Installing LWK</a></h1>
<p>LWK is available for several languages.</p>
<h2 id="rust"><a class="header" href="#rust">Rust</a></h2>
<p>You can use the crates released on <a href="https://crates.io">crates.io</a></p>
<pre><code class="language-rust ignore">[dependencies]
lwk_wollet = "0.11.0"
lwk_signer = "0.11.0"
lwk_common = "0.11.0"</code></pre>
<h2 id="python"><a class="header" href="#python">Python</a></h2>
<p>You can use the official python package: <a href="https://pypi.org/project/lwk/">lwk</a></p>
<pre><code class="language-shell ignore">pip install lwk
</code></pre>
<h2 id="javascripttypescript-wasm"><a class="header" href="#javascripttypescript-wasm">Javascript/Typescript (Wasm)</a></h2>
<h3 id="wasm-module"><a class="header" href="#wasm-module">Wasm module</a></h3>
<p>Install LWK</p>
<pre><code class="language-shell ignore">npm install lwk_wasm
</code></pre>
<p>Import LWK</p>
<pre><code class="language-typescript ignore">const lwk = require('lwk_wasm');
</code></pre>
<h3 id="node-module"><a class="header" href="#node-module">Node module</a></h3>
<p>Install LWK</p>
<pre><code class="language-shell ignore">npm install lwk_node
</code></pre>
<p>Import LWK</p>
<pre><code class="language-typescript ignore">const lwk = require('lwk_node');
</code></pre>
<h2 id="iosswift"><a class="header" href="#iosswift">iOS/Swift</a></h2>
<h2 id="androidkotlin"><a class="header" href="#androidkotlin">Android/Kotlin</a></h2>
<h2 id="react-native"><a class="header" href="#react-native">React Native</a></h2>
<h2 id="go"><a class="header" href="#go">Go</a></h2>
<h2 id="c"><a class="header" href="#c">C#</a></h2>
<pre><code class="language-shell ignore">dotnet add package LiquidWalletKit --version 0.8.2
</code></pre>
<p>Please open an issue if you need a more recent version</p>
<h2 id="flutterdart"><a class="header" href="#flutterdart">Flutter/Dart</a></h2>
<div style="break-before: page; page-break-before: always;"></div><h1 id="lwk-basics"><a class="header" href="#lwk-basics">LWK Basics</a></h1>
<p>LWK is a versatile library designed for a wide range of Liquid applications, from server integrations and mobile wallets to secure, standalone offline signers. Its flexibility allows developers to find the perfect balance between security, performance, and user experience for their specific needs.</p>
<h2 id="how-lwk-works-a-step-by-step-walkthrough"><a class="header" href="#how-lwk-works-a-step-by-step-walkthrough">How LWK Works: A Step-by-Step Walkthrough</a></h2>
<p>This guide will walk you through the core components of LWK and show how they interact to manage and sign Liquid transactions. We'll cover the following steps in detail:</p>
<ul>
<li><strong>Create a Signer</strong>: First you will see how LWK manages private keys.</li>
<li><strong>Create a Wallet</strong>: Next, you'll create a wallet to track your funds and handle your addresses.</li>
<li><strong>Update the Wallet</strong>: You'll learn how to sync your wallet with blockchain data to get an accurate view of your balances.</li>
<li><strong>Create a Transaction</strong>: This step covers how to build a new transaction, specifying inputs and outputs.</li>
<li><strong>Sign a Transaction</strong>: Here, we'll demonstrate how to use the private keys from your signer to sign a transaction.</li>
<li><strong>Broadcast a Transaction</strong>: Finally, you'll learn how to send your signed transaction to the Liquid network.</li>
</ul>
<hr />
<p>Next: <a href="signer.html">Create a LWK signer</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="signers"><a class="header" href="#signers">Signers</a></h1>
<p>In LWK, the management of private keys is delegated to a specialized component called <strong>Signer</strong>.</p>
<p>The primary tasks of a signer are:</p>
<ul>
<li>provide <code>xpub</code>s, which are used to create wallets</li>
<li>sign transactions</li>
</ul>
<h2 id="types-of-signers"><a class="header" href="#types-of-signers">Types of Signers</a></h2>
<p>LWK has two signer types:</p>
<ul>
<li><strong>Software Signers</strong>: store the private keys in memory. This is the simplest signer to integrate and interact with.</li>
<li><strong>Hardware Signers</strong>: LWK provides specific integrations for hardware wallets, such as the Blockstream Jade. These signers keep the private keys completely isolated from the computer.</li>
</ul>
<p>While hardware signers are inherently more secure, LWK's design allows you to enhance the security of software signers as well. For example, a software signer can be run on an isolated machine or a mobile app might store the mnemonic (seed) encrypted, only decrypting it when a signature is required.</p>
<p>This guide will focus on software signers. For more details on hardware signers, please see the <a href="jade.html">Jade documentation</a>.</p>
<h2 id="create-signer"><a class="header" href="#create-signer">Create Signer</a></h2>
<p>To create a signer you need a mnemonic.
You can generate a new one with <code>bip39::Mnemonic::generate()</code>.
Then you can create a software signer with <code>SwSigner::new()</code>.</p>
<custom-tabs category="lang">
<div slot="title">Rust</div>
<section>
<pre><code class="language-rust ignore">use lwk_signer::{bip39::Mnemonic, SwSigner};

let mnemonic = Mnemonic::generate(12)?;
let is_mainnet = false;

let signer = SwSigner::new(&amp;mnemonic.to_string(), is_mainnet)?;</code></pre>
</section>
<div slot="title">Python</div>
<section>
<pre><code class="language-python">mnemonic = Mnemonic.from_random(12)
network = Network.testnet()
signer = Signer(mnemonic, network)
</code></pre>
</section>
<div slot="title">Javascript</div>
<section>
<pre><code class="language-typescript">const mnemonic = lwk.Mnemonic.fromRandom(12);
const network = lwk.Network.testnet();
const signer = new lwk.Signer(mnemonic, network);
</code></pre>
</section>
</custom-tabs>
<h2 id="get-xpub"><a class="header" href="#get-xpub">Get Xpub</a></h2>
<p>Once you have a signer you need to get some an extended public key (<code>xpub</code>),
which can be used to create a wallet that requires signature from the signer.</p>
<p>The xpub is obtained with <code>Signer::keyorigin_xpub()</code>, which also includes the keyorigin information: signer fingerprint and derivation path from master key to the returned xpub, e.g. <code>[ffffffff/84h/1h/0h]xpub...</code>.</p>
<custom-tabs category="lang">
<div slot="title">Rust</div>
<section>
<pre><code class="language-rust ignore">let bip = lwk_common::Bip::Bip84;
let xpub = signer.keyorigin_xpub(bip, is_mainnet);</code></pre>
</section>
<div slot="title">Python</div>
<section>
<pre><code class="language-python">xpub = signer.keyorigin_xpub(Bip.new_bip84())
</code></pre>
</section>
<div slot="title">Javascript</div>
<section>
<pre><code class="language-typescript">const xpub = signer.keyoriginXpub(lwk.Bip.bip84());
</code></pre>
</section>
</custom-tabs>
<p>For particularly simple cases, such as single sig, you can get the CT descriptor directly from the signer, for instance using <code>Signer::wpkh_slip77_descriptor()</code>.</p>
<hr />
<p>Next: <a href="wollet.html">Watch-Only Wallets</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="watch-only-wallets"><a class="header" href="#watch-only-wallets">Watch-Only Wallets</a></h1>
<p>In LWK, the core functions of a wallet are split between two components for enhanced security: <strong>Signers</strong> manage private keys, while the <strong>Wollet</strong> handles everything else.</p>
<p>The term "Wollet" is not a typo; it stands for "Watch-Only wallet." A wollet provides view-only access, allowing you to generate addresses and see your balance without ever handling private keys. This design is crucial for security, as it keeps your private keys isolated.</p>
<p>A LWK wollet can perform the following operations:</p>
<ul>
<li>Generate addresses</li>
<li>List transactions</li>
<li>Get balance</li>
<li>Create transactions (but not sign them)</li>
</ul>
<h2 id="ct-descriptors"><a class="header" href="#ct-descriptors">CT descriptors</a></h2>
<p>A Wollet is defined by a <a href="https://github.com/ElementsProject/ELIPs/blob/main/elip-0150.mediawiki">CT descriptor</a>, which consists in a Bitcoin descriptor plus the descriptor blinding key.</p>
<p>In the previous section, we saw how to generate a single sig CT descriptor from a signer with <code>Signer::wpkh_slip77_descriptor()</code>, which returns something like:</p>
<pre><code class="language-ignore">ct(slip77(...),elwpkh([ffffffff/84h/1h/0h]xpub...))
</code></pre>
<ul>
<li><code>ct(...,...)</code></li>
<li><code>slip77(...)</code> the descriptor blinding key</li>
<li><code>el</code> the "Elements" prefix</li>
<li><code>wpkh([ffffffff/84h/1h/0h]xpub...)</code> the "Bitcoin descriptor", with</li>
</ul>
<p>The CT descriptors defines the wallet spending conditions. In this case it requires a single signature from a specific signer.</p>
<p>LWK supports more complex spending conditions, such as <a href="multisig.html">multisig</a>.</p>
<h2 id="create-a-wollet"><a class="header" href="#create-a-wollet">Create a Wollet</a></h2>
<p>From the CT descriptor, you need to generate a <code>WolletDescriptor</code>. Calling <code>WolletDescriptor::from_str()</code> will perform some basic validation of the descriptor, and fails if the descriptor is not supported by LWK.</p>
<p>Once you have a <code>WolletDescriptor</code> you can create a <code>Wollet</code> using either <code>Wollet::without_persist()</code> (keeps wallet data in memory) or <code>Wollet::with_fs_persist()</code> (stores wallet data on filesystem).</p>
<p>LWK also allows <code>Wollet</code>s to have a <a href="persister.html">custom persister</a>.</p>
<custom-tabs category="lang">
<div slot="title">Rust</div>
<section>
<pre><code class="language-rust ignore">use lwk_wollet::{ElementsNetwork, Wollet, WolletDescriptor};

let desc = signer.wpkh_slip77_descriptor()?;
let wd = WolletDescriptor::from_str(&amp;desc)?;
let network = ElementsNetwork::LiquidTestnet;
let mut wollet = Wollet::without_persist(network, wd)?;</code></pre>
</section>
<div slot="title">Python</div>
<section>
<pre><code class="language-python">desc = signer.wpkh_slip77_descriptor()
wollet = Wollet(network, desc, datadir=None)
</code></pre>
</section>
<div slot="title">Javascript</div>
<section>
<pre><code class="language-typescript">const desc = signer.wpkhSlip77Descriptor();
const wollet = new lwk.Wollet(network, desc);
</code></pre>
</section>
</custom-tabs>
<h2 id="generate-addresses"><a class="header" href="#generate-addresses">Generate Addresses</a></h2>
<p>You can generate a wallet confidential address with <code>Wollet::address()</code>.</p>
<p>This address can receive any Liquid asset or amount.</p>
<custom-tabs category="lang">
<div slot="title">Rust</div>
<section>
<pre><code class="language-rust ignore">let addr = wollet.address(None)?;</code></pre>
</section>
<div slot="title">Python</div>
<section>
<pre><code class="language-python">addr = wollet.address(None)

</code></pre>
</section>
<div slot="title">Javascript</div>
<section>
<pre><code class="language-typescript">const addr = wollet.address(null).address().toString();
</code></pre>
</section>
</custom-tabs>
<h2 id="get-transactions-and-balance"><a class="header" href="#get-transactions-and-balance">Get Transactions and Balance</a></h2>
<p>It's possibile to get the list of wallet transactions with <code>Wollet::transactions()</code> and the balance <code>Wollet::balance()</code>.</p>
<p>Note: Liquid transactions are confidential, meaining that only sender and receiver can see their asset and amount. <code>Wollet</code> unblinds the transactions and returns unblinded data that can be shown to the user.</p>
<p><code>Wollet</code> however does not have internet access.
To fetch (new) wallet data, you need to use a "client" that fetches wallet transactions from some server.
In the next section we explain how (new) blockchain data can be obtained and added to the wallet.</p>
<custom-tabs category="lang">
<div slot="title">Rust</div>
<section>
<pre><code class="language-rust ignore">let txs = wollet.transactions()?;
let balance = wollet.balance()?;</code></pre>
</section>
<div slot="title">Python</div>
<section>
<pre><code class="language-python">txs = wollet.transactions()
balance = wollet.balance()
</code></pre>
</section>
<div slot="title">Javascript</div>
<section>
<pre><code class="language-typescript">const txs = wollet.transactions();
const balance = wollet.balance();
</code></pre>
</section>
</custom-tabs>
<hr />
<p>Next: <a href="scan.html">Update the Wallet</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="update-the-wallet"><a class="header" href="#update-the-wallet">Update the Wallet</a></h1>
<p>The fact that <code>Wollet</code> does have access to internet is a deliberate choice.
This allows <code>Wollet</code> to work offline, where they can generate addresses.</p>
<p>The connection is handled by a specific component, a Blockchain <strong>Client</strong>.
Blockchain clients connect to the specified server a fetch the wallet data from the blockchain.</p>
<p>LWK currently support 3 types of servers:</p>
<ul>
<li>Electrum Servers</li>
<li>Esplora Servers</li>
<li>Waterfalls Servers</li>
</ul>
<p>To delve into their differences and strength points see our <a href="clients.html">dedicated section</a>.</p>
<h2 id="create-a-client"><a class="header" href="#create-a-client">Create a Client</a></h2>
<p>In this guide we will use an <code>EsploraClient</code>.</p>
<p>You can create a new client with <code>EsploraClient::new()</code>, specifying the URL of the service.</p>
<h2 id="scan-the-blockchain"><a class="header" href="#scan-the-blockchain">Scan the Blockchain</a></h2>
<p>Given a <code>Wollet</code> you can call <code>EsploraClient::full_scan()</code>,
which performs a series of network calls that scan the blockchain to find transactions relevant for the wallet.</p>
<p><code>EsploraClient::full_scan()</code> has a stopping mechanisms that relies on BIP44 GAP LIMIT.
This might not fit every use cases.
In case you have large sequences of consecutive unused addresses you can use
<code>EsploraClient::full_scan_to_index()</code>.</p>
<h2 id="apply-the-update"><a class="header" href="#apply-the-update">Apply the Update</a></h2>
<p><code>EsploraClient::full_scan()</code> fetches, parses, (locally) unblind and serialized the fetched data in returned value, an <code>Update</code>.
The <code>Update</code> can be applied to the <code>Wollet</code> using <code>Wollet::apply_update()</code>.</p>
<p>After applying the update the wollet data will include the new transaction downloaded,
for instance more transactions can be returned and balance can increase (or decrease).</p>
<custom-tabs category="lang">
<div slot="title">Rust</div>
<section>
<pre><code class="language-rust ignore">use lwk_wollet::clients::blocking::EsploraClient;

// let url = "https://blockstream.info/liquidtestnet/api";
// let url = "https://blockstream.info/liquid/api";

let mut client = EsploraClient::new(&amp;url, network)?;

if let Some(update) = client.full_scan(&amp;wollet)? {
    wollet.apply_update(update)?;
}</code></pre>
</section>
<div slot="title">Python</div>
<section>
<pre><code class="language-python">url = "https://blockstream.info/liquidtestnet/api"
client = EsploraClient(url, network)

update = client.full_scan(wollet)
wollet.apply_update(update)
</code></pre>
</section>
<div slot="title">Javascript</div>
<section>
<pre><code class="language-typescript">const url = "https://waterfalls.liquidwebwallet.org/liquidtestnet/api";
const client = new lwk.EsploraClient(network, url, true, 4, false);

const update = await client.fullScan(wollet);
if (update) {
    wollet.applyUpdate(update);
}
</code></pre>
</section>
</custom-tabs>
<hr />
<p>Next: <a href="tx.html">Create a transaction</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="transaction-creation"><a class="header" href="#transaction-creation">Transaction Creation</a></h1>
<p>With a <code>Wollet</code> you can generate an address,
which can be used to receive some funds.
You can fetch the transactions receiving the funds using a "client",
and apply them to the wallet.
Now that the <code>Wollet</code> has a balance, it is able to craft transactions sending funds to desired destination.</p>
<p>The first step is construction a <code>TxBuilder</code> (or <code>WolletTxBuilder</code>), using <code>TxBuilder::new()</code> or <code>Wollet::tx_builder()</code>.
You can now specify how to build the transaction using the methods exposed by the <code>TxBuilder</code>.</p>
<h2 id="add-a-recipient"><a class="header" href="#add-a-recipient">Add a Recipient</a></h2>
<p>If you want to send some funds you need this information:</p>
<ul>
<li>Address: destination (confidential) address provided by the receiver</li>
<li>Amount: number of units of the asset (satoshi) to be sent.</li>
<li>Asset: identifier of the asset that should be sent</li>
</ul>
<p>Then you can call <code>TxBuilder::add_recipient()</code> to create an output which sends the amount of the asset, to the specified address.</p>
<p>You can add multiple recipients to the same transaction.</p>
<h2 id="advanced-options"><a class="header" href="#advanced-options">Advanced Options</a></h2>
<p>LWK allows to construct complex transactions, here there are few examples</p>
<ul>
<li>Set fee rate with <code>TxBuilder::fee_rate()</code></li>
<li><a href="manual.html">Manual coin selection</a></li>
<li><a href="external.html">External UTXOS</a></li>
<li><a href="explicit.html">Explicit inputs and outputs</a></li>
<li><a href="sendall.html">Send all LBTC</a></li>
<li><a href="issuance.html">Issuance</a>, <a href="reissuance.html">reissuance</a>, <a href="burn.html">burn</a></li>
</ul>
<h2 id="construct-the-transaction-pset"><a class="header" href="#construct-the-transaction-pset">Construct the Transaction (PSET)</a></h2>
<p>Once you set all the desired options to the <code>TxBuilder</code>.
You can construct the transaction calling <code>TxBuilder::finish()</code>.
This will return a Partially Signed Elements Transaction (<a href="https://github.com/ElementsProject/elements/blob/master/doc/pset.mediawiki">PSET</a>),
a transaction encoded in a format that facilitates sharing the transaction with signers.</p>
<custom-tabs category="lang">
<div slot="title">Rust</div>
<section>
<pre><code class="language-rust ignore">let mut pset = wollet
    .tx_builder()
    .add_recipient(&amp;address, sats, lbtc)?
    .finish()?;</code></pre>
</section>
<div slot="title">Python</div>
<section>
<pre><code class="language-python">b = network.tx_builder()
b.add_recipient(address, sats, lbtc)
pset = b.finish(wollet)
</code></pre>
</section>
<div slot="title">Javascript</div>
<section>
<pre><code class="language-typescript">const sats = BigInt(1000);
const address = new lwk.Address("&lt;address&gt;");
const asset = new lwk.AssetId("&lt;asset&gt;");

var builder = new lwk.TxBuilder(network)
builder = builder.addRecipient(address, sats, asset)
var pset = builder.finish(wollet)
</code></pre>
</section>
</custom-tabs>
<hr />
<p>Next: <a href="sign.html">Sign Transaction</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="transaction-signing"><a class="header" href="#transaction-signing">Transaction Signing</a></h1>
<p>Once you have created a PSET now you need to add some signatures to it.
This is done by the <code>Signer</code>,
however the signer might be isolated,
so we need some mechanisms to allow the signer to understand what is signing.</p>
<h2 id="get-the-pset-details"><a class="header" href="#get-the-pset-details">Get the PSET details</a></h2>
<p>This is done with <code>Wollet::get_details()</code>, which returns:</p>
<ul>
<li>missing signatures and the respective signers' fingerprints</li>
<li>net balance, the effect that transaction has on wallet (e.g. how much funds are sent out of the wallet)</li>
</ul>
<p>If the <code>Signer</code> fingeprint is included in the missing signatures,
then a <code>Signer</code> with that fingeprint expected to sign.</p>
<p>The balance can be shown to the user or validated against the <code>Signer</code> expectations.</p>
<p>It's worth noticing that <code>Wollet</code>s can work without internet,
so offline <code>Signer</code>s can have <code>Wollet</code>s instance to enhance the validation performed before signing.</p>
<custom-tabs category="lang">
<div slot="title">Rust</div>
<section>
<pre><code class="language-rust ignore">let details = wollet.get_details(&amp;pset)?;</code></pre>
</section>
<div slot="title">Python</div>
<section>
<pre><code class="language-python">details = wollet.pset_details(pset)
</code></pre>
</section>
<div slot="title">Javascript</div>
<section>
<pre><code class="language-typescript">const details = wollet.psetDetails(pset);
</code></pre>
</section>
</custom-tabs>
<h2 id="sign-the-pset"><a class="header" href="#sign-the-pset">Sign the PSET</a></h2>
<p>Once you have performed enough validation, you can call <code>Signer::sign</code>.
Which adds signatures from <code>Signer</code> to the PSET.</p>
<p>Once the PSET has enough signatures, you can broadcast to the Liquid Network.</p>
<custom-tabs category="lang">
<div slot="title">Rust</div>
<section>
<pre><code class="language-rust ignore">let sigs_added = signer.sign(&amp;mut pset)?;
assert_eq!(sigs_added, 1);</code></pre>
</section>
<div slot="title">Python</div>
<section>
<pre><code class="language-python">pset = signer.sign(pset)
</code></pre>
</section>
<div slot="title">Javascript</div>
<section>
<pre><code class="language-typescript">pset = signer.sign(pset)
</code></pre>
</section>
</custom-tabs>
<hr />
<p>Next: <a href="broadcast.html">Broadcast a Transaction</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="transaction-broadcast"><a class="header" href="#transaction-broadcast">Transaction Broadcast</a></h1>
<p>When a PSET has enough signatures, it's ready to be broadcasted to the Liquid Network.</p>
<h2 id="finalize-the-pset"><a class="header" href="#finalize-the-pset">Finalize the PSET</a></h2>
<p>First you need to call <code>Wollet::finalize()</code> to finalize the PSET and extract the signed transaction.</p>
<h2 id="broadcast-the-transaction"><a class="header" href="#broadcast-the-transaction">Broadcast the Transaction</a></h2>
<p>The transaction returned by the previous step can be sent to the Liquid Network with <code>EsploraClient::broadcast()</code>.</p>
<h2 id="apply-the-transaction"><a class="header" href="#apply-the-transaction">Apply the Transaction</a></h2>
<p>If you send a transaction you might want to see the balance decrease immediately.
With LWK this does not happens automatically,
you can do a "full scan" and apply the returned update.
However this requires network calls and it might be slow,
if you want your balance to be updated immediately,
you can call <code>Wollet::apply_tx()</code>.</p>
<custom-tabs category="lang">
<div slot="title">Rust</div>
<section>
<pre><code class="language-rust ignore">let tx = wollet.finalize(&amp;mut pset)?;
let txid = client.broadcast(&amp;tx)?;

// (optional)
wollet.apply_transaction(tx)?;</code></pre>
</section>
<div slot="title">Python</div>
<section>
<pre><code class="language-python">pset = wollet.finalize(pset)
const tx = pset.extractTx();
const txid = await client.broadcastTx(tx)

// (optional)
wollet.applyTransaction(tx);
</code></pre>
</section>
<div slot="title">Javascript</div>
<section>
<pre><code class="language-typescript">pset = wollet.finalize(pset)
const tx = pset.extractTx();
const txid = await client.broadcastTx(tx)

// (optional)
wollet.applyTransaction(tx);
</code></pre>
</section>
</custom-tabs>
<hr />
<p>Next: <a href="advanced.html">Advanced Features</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="liquid-multisig"><a class="header" href="#liquid-multisig">Liquid Multisig</a></h1>
<p>Liquid has a very similar scripting model with respect to Bitcoin.
It allows to create complex spending conditions for your wallets.</p>
<p>A relatively simple, yet powerful, example is <strong>multisig</strong>.
In a multisig wallet you need <em>n</em> signatures from a set of <em>m</em> public keys to spend a wallet UTXO.</p>
<p>In this guide we will explain how to setup and operate a Liquid Multisig wallet.</p>
<h2 id="setup"><a class="header" href="#setup">Setup</a></h2>
<p>We want to create a <em>2of3</em> between Alice, Bob and Carol.</p>
<p>First each multisig participant creates their signer.
Then they get their <em>xpub</em>, and share it with the coordinator, in this case Carol.
Carol uses the xpubs to construct the multisig CT descriptor.
Finally Carol shares the multisig CT descriptor with Alice and Bob.</p>
<pre class="mermaid">sequenceDiagram
    participant A as Alice
    participant B as Bob
    participant C as Carol&lt;br&gt;(coordinator)
    Note over A: signer A 🔑
    Note over B: signer B 🔑
    Note over C: signer C 🔑
    A-&gt;&gt;C: xpub A
    B-&gt;&gt;C: xpub B
    C-&gt;&gt;C: xpub C
    Note over C: Create&lt;br&gt;CT descriptor👀
    C-&gt;&gt;B: CT descriptor👀
    C-&gt;&gt;A: CT descriptor👀
</pre>
<div class="warning">
⚠️ It's important that all participants in a multisig know the CT descriptors, as it is necessary to validate if addresses and (U)TXO belong to the wallet.
</div>
<custom-tabs category="lang">
<div slot="title">Rust</div>
<section>
<pre><code class="language-rust ignore">let is_mainnet = false;
// Derivation for multisig
let bip = lwk_common::Bip::Bip87;

// Alice creates their signer and gets the xpub
let mnemonic_a = Mnemonic::generate(12)?;
let signer_a = SwSigner::new(&amp;mnemonic_a.to_string(), is_mainnet)?;
let xpub_a = signer_a.keyorigin_xpub(bip, is_mainnet)?;

// Bob creates their signer and gets the xpub
let mnemonic_b = Mnemonic::generate(12)?;
let signer_b = SwSigner::new(&amp;mnemonic_b.to_string(), is_mainnet)?;
let xpub_b = signer_b.keyorigin_xpub(bip, is_mainnet)?;

// Carol, who acts as a coordinator, creates their signer and gets the xpub
let mnemonic_c = Mnemonic::generate(12)?;
let signer_c = SwSigner::new(&amp;mnemonic_c.to_string(), is_mainnet)?;
let xpub_c = signer_c.keyorigin_xpub(bip, is_mainnet)?;

// Carol generates a random SLIP77 descriptor blinding key
let mut slip77_rand_key = [0u8; 32];
use rand::{thread_rng, Rng};
thread_rng().fill(&amp;mut slip77_rand_key);
let slip77_rand_key = slip77_rand_key.to_hex();
let desc_blinding_key = format!("slip77({slip77_rand_key})");

// Carol uses the collected xpubs and the descriptor blinding key to create
// the 2of3 descriptor
let threshold = 2;
let desc = format!("ct({desc_blinding_key},elwsh(multi({threshold},{xpub_a}/&lt;0;1&gt;/*,{xpub_b}/&lt;0;1&gt;/*,{xpub_c}/&lt;0;1&gt;/*)))");
// Validate the descriptor string
let wd = WolletDescriptor::from_str(&amp;desc)?;</code></pre>
</section>
<div slot="title">Python</div>
<section>
<pre><code class="language-python">network = Network.testnet()
# Derivation for multisig
bip = Bip.new_bip87()

# Alice creates their signer and gets the xpub
signer_a = Signer.random(network)
xpub_a = signer_a.keyorigin_xpub(bip);

# Bob creates their signer and gets the xpub
signer_b = Signer.random(network)
xpub_b = signer_b.keyorigin_xpub(bip);

# Carol, who acts as a coordinator, creates their signer and gets the xpub
signer_c = Signer.random(network)
xpub_c = signer_c.keyorigin_xpub(bip);

# Carol generates a random SLIP77 descriptor blinding key
import os
slip77_rand_key = os.urandom(32).hex()
desc_blinding_key = f"slip77({slip77_rand_key})"

# Carol uses the collected xpubs and the descriptor blinding key to create
# the 2of3 descriptor
threshold = 2;
desc = f"ct({desc_blinding_key},elwsh(multi({threshold},{xpub_a}/&lt;0;1&gt;/*,{xpub_b}/&lt;0;1&gt;/*,{xpub_c}/&lt;0;1&gt;/*)))"
# Validate the descriptor string
wd = WolletDescriptor(desc)
</code></pre>
</section>
<div slot="title">Javascript</div>
<section>
<pre><code class="language-typescript">const network = lwk.Network.testnet();
// Derivation for multisig
const bip = lwk.Bip.bip87();

// Alice creates their signer and gets the xpub
const mnemonic_a = lwk.Mnemonic.fromRandom(12);
const signer_a = new lwk.Signer(mnemonic_a, network);
const xpub_a = signer_a.keyoriginXpub(bip);

// Bob creates their signer and gets the xpub
const mnemonic_b = lwk.Mnemonic.fromRandom(12);
const signer_b = new lwk.Signer(mnemonic_b, network);
const xpub_b = signer_b.keyoriginXpub(bip);

// Carol, who acts as a coordinator, creates their signer and gets the xpub
const mnemonic_c = lwk.Mnemonic.fromRandom(12);
const signer_c = new lwk.Signer(mnemonic_c, network);
const xpub_c = signer_c.keyoriginXpub(bip);

// Carol generates a random SLIP77 descriptor blinding key
const slip77_rand_key = "&lt;random-64-hex-chars&gt;";
const desc_blinding_key = `slip77(${slip77_rand_key})`;

// Carol uses the collected xpubs and the descriptor blinding key to create
// the 2of3 descriptor
const threshold = 2;
const desc = `ct(${desc_blinding_key},elwsh(multi(${threshold},${xpub_a}/&lt;0;1&gt;/*,${xpub_b}/&lt;0;1&gt;/*,${xpub_c}/&lt;0;1&gt;/*)))`;
// Validate the descriptor string
const wd = new lwk.WolletDescriptor(desc);
</code></pre>
</section>
</custom-tabs>
<p>In this example Carol creates the SLIP77 key at random, however this is not mandatory and valid alternatives are:</p>
<ul>
<li>"elip151", to deterministically derive the descriptor blinding key from the "bitcoin" descriptor;</li>
<li>derive a SLIP77 deterministic key from a signer, however this descriptor blinding key might be re used in other descriptors.</li>
</ul>
<h2 id="receive-and-monitor"><a class="header" href="#receive-and-monitor">Receive and monitor</a></h2>
<p>The Liquid Multisig wallet is identified by the CT descriptor created during setup.
The descriptor encodes all the information needed to derive scriptpubkeys and blinding keys which are necessary to operate the wallet. In general, it also contains the xpubs <em>key origin</em>, information needed to by signers to sign, consisting in the signer fingerprint and derivation paths.</p>
<p>With the wallet CT descriptor you can:</p>
<ul>
<li>Generate wallet (confidential) addresses</li>
<li>Get the (unblinded) list of the wallet transactions</li>
<li>Get the wallet balance</li>
</ul>
<custom-tabs category="lang">
<div slot="title">Rust</div>
<section>
<pre><code class="language-rust ignore">// Carol creates the wollet
let network = ElementsNetwork::LiquidTestnet;
let mut wollet_c = Wollet::without_persist(network, wd)?;

// With the wollet, Carol can obtain addresses, transactions and balance
let addr = wollet_c.address(None)?;
let txs = wollet_c.transactions()?;
let balance = wollet_c.balance()?;

// Update the wollet state
let url = "https://blockstream.info/liquidtestnet/api";
let mut client = EsploraClient::new(&amp;url, network)?;

if let Some(update) = client.full_scan(&amp;wollet_c)? {
    wollet_c.apply_update(update)?;
}</code></pre>
</section>
<div slot="title">Python</div>
<section>
<pre><code class="language-python"># Carol creates the wollet
wollet_c = Wollet(network, wd, datadir=None)

# With the wollet, Carol can obtain addresses, transactions and balance
addr = wollet_c.address(None);
txs = wollet_c.transactions();
balance = wollet_c.balance();

# Update the wollet state
url = "https://blockstream.info/liquidtestnet/api"
client = EsploraClient(url, network)

update = client.full_scan(wollet_c)
wollet_c.apply_update(update)
</code></pre>
</section>
<div slot="title">Javascript</div>
<section>
<pre><code class="language-typescript">// Carol creates the wollet
const wollet_c = new lwk.Wollet(network, wd);

// With the wollet, Carol can obtain addresses, transactions and balance
const addr = wollet_c.address(null).address().toString();
const txs = wollet_c.transactions();
const balance = wollet_c.balance();

// Update the wollet state
const url = "https://waterfalls.liquidwebwallet.org/liquidtestnet/api";
const client = new lwk.EsploraClient(network, url, true, 4, false);

const update = await client.fullScan(wollet_c);
if (update) {
    wollet_c.applyUpdate(update);
}
</code></pre>
</section>
</custom-tabs>
<p>Note that for generating addresses, getting transactions and balance, you have the same procedure for both singlesig and multisig wallets.</p>
<h2 id="send"><a class="header" href="#send">Send</a></h2>
<p>As for addresses, transactions and balance, to create a multisig transaction you only need the CT descriptor.
In this example Carol creates the transaction.
Since she created the transaction, she's comfortable in skipping validation and she also signs it.
However the wallet is a 2of3, so it needs either Alice or Bob to fully sign the transaction.
Carol sends the transaction (in PSET format) to Bob.
Bob examines the PSET and checks that it does what it's supposed to do (e.g. outgoing addresses, assets, amounts and fees), then it signs the PSET and sends it back to Carol.
The PSET is now fully signed, Carol can finalize it and broadcast the transaction.</p>
<pre class="mermaid">sequenceDiagram
    participant A as Alice
    participant B as Bob
    participant C as Carol&lt;br&gt;(coordinator)
    Note over C: Create PSET&lt;br&gt;(using CT descriptor👀)
    Note over C: signer C 🔑 signs PSET
    C-&gt;&gt;B: PSET
    Note over B: Analyze PSET&lt;br&gt;(using CT descriptor👀)
    Note over B: signer B 🔑 signs PSET
    B-&gt;&gt;C: PSET
    Note over C: Finalize PSET and&lt;br&gt;extract TX
    Note over C: Broadcast TX
</pre>
<custom-tabs category="lang">
<div slot="title">Rust</div>
<section>
<pre><code class="language-rust ignore">// Carol creates a transaction send few sats to a certain address
let address = "&lt;address&gt;";
let sats = 1000;
let lbtc = network.policy_asset();

let mut pset = wollet_c
    .tx_builder()
    .add_recipient(&amp;address, sats, lbtc)?
    .finish()?;

// Carol signs the transaction
let sigs_added = signer_c.sign(&amp;mut pset)?;
assert_eq!(sigs_added, 1);

// Carol sends the PSET to Bob
// Bob wants to analyze the PSET before signing, thus he creates a wollet
let wd = WolletDescriptor::from_str(&amp;desc)?;
let mut wollet_b = Wollet::without_persist(network, wd)?;
if let Some(update) = client.full_scan(&amp;wollet_b)? {
    wollet_b.apply_update(update)?;
}
// Then Bob uses the wollet to analyze the PSET
let details = wollet_b.get_details(&amp;pset)?;
// PSET has a reasonable fee
assert!(details.balance.fee &lt; 100);
// PSET has a signature from Carol
let fingerprints_has = details.fingerprints_has();
assert_eq!(fingerprints_has.len(), 1);
assert!(fingerprints_has.contains(&amp;signer_c.fingerprint()));
// PSET needs a signature from either Bob or Carol
let fingerprints_missing = details.fingerprints_missing();
assert_eq!(fingerprints_missing.len(), 2);
assert!(fingerprints_missing.contains(&amp;signer_a.fingerprint()));
assert!(fingerprints_missing.contains(&amp;signer_b.fingerprint()));
// PSET has a single recipient, with data matching what was specified above
assert_eq!(details.balance.recipients.len(), 1);
let recipient = details.balance.recipients[0].clone();
assert_eq!(recipient.address.unwrap(), address);
assert_eq!(recipient.asset.unwrap(), lbtc);
assert_eq!(recipient.value.unwrap(), sats);

// Bob is satisified with the PSET and signs it
let sigs_added = signer_b.sign(&amp;mut pset)?;
assert_eq!(sigs_added, 1);

// Bob sends the PSET back to Carol
// Carol checks that the PSET has enough signatures
let details = wollet_c.get_details(&amp;pset)?;
assert_eq!(details.fingerprints_has().len(), 2);

// Carol finalizes the PSET and broadcast the transaction
let tx = wollet_c.finalize(&amp;mut pset)?;
let txid = client.broadcast(&amp;tx)?;</code></pre>
</section>
<div slot="title">Python</div>
<section>
<pre><code class="language-python"># Carol creates a transaction send few sats to a certain address
address = "&lt;address&gt;"
sats = 1000
lbtc = network.policy_asset()

b = network.tx_builder()
b.add_recipient(address, sats, lbtc)
pset = b.finish(wollet_c)

pset = signer_c.sign(pset)

# Carol sends the PSET to Bob
# Bob wants to analyze the PSET before signing, thus he creates a wollet
wd = WolletDescriptor(desc)
wollet_b = Wollet(network, wd, datadir=None)
update = client.full_scan(wollet_b)
wollet_b.apply_update(update)
# Then Bob uses the wollet to analyze the PSET
details = wollet_b.pset_details(pset)
# PSET has a reasonable fee
assert details.balance().fee() &lt; 100
# PSET has a signature from Carol
fingerprints_has = details.fingerprints_has()
assert len(fingerprints_has) == 1
assert signer_c.fingerprint() in fingerprints_has
# PSET needs a signature from either Bob or Carol
fingerprints_missing = details.fingerprints_missing()
assert len(fingerprints_missing) == 2
assert signer_a.fingerprint() in fingerprints_missing
assert signer_b.fingerprint() in fingerprints_missing
# PSET has a single recipient, with data matching what was specified above
assert len(details.balance().recipients()) == 1
recipient = details.balance().recipients()[0]
assert str(recipient.address()) == str(address)
assert recipient.asset() == lbtc
assert recipient.value() == sats

# Bob is satisified with the PSET and signs it
pset = signer_b.sign(pset)

# Bob sends the PSET back to Carol
# Carol checks that the PSET has enough signatures
details = wollet_c.pset_details(pset)
fingerprints_has = details.fingerprints_has()
assert len(fingerprints_has) == 2

# Carol finalizes the PSET and broadcast the transaction
tx = pset.finalize()
txid = client.broadcast(tx)
</code></pre>
</section>
<div slot="title">Javascript</div>
<section>
<pre><code class="language-typescript">// Carol creates a transaction send few sats to a certain address
const sats = BigInt(1000);
const address = new lwk.Address("&lt;address&gt;");
const asset = new lwk.AssetId("&lt;asset&gt;");

var builder = new lwk.TxBuilder(network)
builder = builder.addRecipient(address, sats, asset)
var pset = builder.finish(wollet_c)

pset = signer_c.sign(pset)

// Carol sends the PSET to Bob
// Bob wants to analyze the PSET before signing, thus he creates a wollet
const wd_b = new lwk.WolletDescriptor(desc);
const wollet_b = new lwk.Wollet(network, wd_b);
const update_b = await client.fullScan(wollet_b);
if (update_b) {
    wollet_b.applyUpdate(update_b);
}
// Then Bob uses the wollet to analyze the PSET
const details = wollet_b.psetDetails(pset);
// PSET has a reasonable fee
console.assert(details.balance().fee() &lt; 100);
// PSET has a signature from Carol
console.assert(details.fingerprintsHas().length === 1);
console.assert(details.fingerprintsHas().includes(signer_c.fingerprint()));
// PSET needs a signature from either Bob or Carol
console.assert(details.fingerprintsMissing().length === 2);
console.assert(details.fingerprintsMissing().includes(signer_a.fingerprint()));
console.assert(details.fingerprintsMissing().includes(signer_b.fingerprint()));
// PSET has a single recipient, with data matching what was specified above
console.assert(details.balance().recipients().length === 1);
const recipient = details.balance().recipients()[0];
console.assert(recipient.address().toString() === address.toString());
console.assert(recipient.asset().toString() === asset.toString());
console.assert(recipient.value() === sats);

// Bob is satisified with the PSET and signs it
pset = signer_b.sign(pset)

// Bob sends the PSET back to Carol
// Carol checks that the PSET has enough signatures
const details_b = wollet_b.psetDetails(pset);
console.assert(details_b.fingerprintsHas().length === 2);

// Carol finalizes the PSET and broadcast the transaction
pset = wollet_c.finalize(pset)
const tx = pset.extractTx();
const txid = await client.broadcastTx(tx);
</code></pre>
</section>
</custom-tabs>
<div class="warning">
⚠️ Bob needs the CT descriptor to obtain the PSET details, in particular the net balance with respect to the wallet, i.e. how much is being sent out of the wallet.
</div>
<p>In this example we went through an example where the coordinator is one of the multisig participants and the PSET is signed serially. In general, this is not the case.
The coordinator can be a utility service, as long as it knows the multisig CT descriptor.
Also the PSET can be signed in parallel, and in this case the coordinator must combine the signed PSET using <code>Wollet::combine()</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="amp0-in-lwk"><a class="header" href="#amp0-in-lwk">AMP0 in LWK</a></h1>
<p><a href="https://blockstream.com/amp/">AMP0</a> (Asset Management Platform version 0) is a service for issuers that allows to enforce specific rules on certain Liquid assets (AMP0 assets).</p>
<p>AMP0 is based on a legacy system and it does not fit the LWK model perfectly.
That is reflected in the LWK AMP0 interface which could be a bit cumbersome to use.</p>
<h2 id="limitations"><a class="header" href="#limitations">Limitations</a></h2>
<p><em>LWK has partial support for AMP0.</em>
For instance it does not allow to issue AMP0 asset, or use accounts with 2FA.</p>
<div class="table-wrapper"><table><thead><tr><th></th><th style="text-align: center">LWK</th><th style="text-align: center">GDK</th><th style="text-align: center">AMP0 API</th></tr></thead><tbody>
<tr><td>Create AMP0 accounts</td><td style="text-align: center">✅</td><td style="text-align: center">✅</td><td style="text-align: center">❌</td></tr>
<tr><td>Receive on AMP0 accounts</td><td style="text-align: center">✅</td><td style="text-align: center">✅</td><td style="text-align: center">❌</td></tr>
<tr><td>Monitor AMP0 accounts</td><td style="text-align: center">✅</td><td style="text-align: center">✅</td><td style="text-align: center">❌</td></tr>
<tr><td>Send from AMP0 accounts</td><td style="text-align: center">✅</td><td style="text-align: center">✅</td><td style="text-align: center">❌</td></tr>
<tr><td>Account with 2FA</td><td style="text-align: center">❌</td><td style="text-align: center">✅</td><td style="text-align: center">❌</td></tr>
<tr><td>issue, reissue, burn AMP0 assets</td><td style="text-align: center">❌</td><td style="text-align: center">❌</td><td style="text-align: center">✅</td></tr>
<tr><td>set restriction for AMP0 assets</td><td style="text-align: center">❌</td><td style="text-align: center">❌</td><td style="text-align: center">✅</td></tr>
</tbody></table>
</div>
<p>If you need full support for AMP0, use <a href="https://github.com/blockstream/gdk">GDK</a> and the AMP0 issuer API.</p>
<h2 id="overview"><a class="header" href="#overview">Overview</a></h2>
<p>To use AMP0 with LWK you need:</p>
<ul>
<li>👀 some Green Watch-Only credentials (username and password) for a Green Wallet with an AMP account</li>
<li>🔑 the corresponding signer available (e.g. Jade or software with the BIP39 mnemonic)</li>
</ul>
<p>Then you can:</p>
<ul>
<li>get addresses for the AMP0 account (👀)</li>
<li>monitor the AMP0 account (get balance and transactions) (👀)</li>
<li>create AMP0 transactions (👀)</li>
<li>sign AMP0 transactions (🔑)</li>
<li>ask AMP0 to cosign transactions (👀)</li>
<li>broadcast AMP0 transactions (👀)</li>
</ul>
<p>Using AMP0 with LWK you can keep the signer separated and operate it accoriding to the desired degree of security and isolation.</p>
<div class="warning">
⚠️ AMP0 is based on a legacy system and it has some pitfalls.
We put some mechanism in order to make it harder to do the wrong thing, anyway callers should be careful when getting new addresses and syncing the wallet.
</div>
<h2 id="setup-1"><a class="header" href="#setup-1">Setup</a></h2>
<p>To use AMP0 with LWK you need to:</p>
<ol>
<li>Create a Liquid wallet (backup its mnemonic/seed)</li>
<li>Create an AMP account (AMP ID)</li>
<li>Create a Liquid Watch-Only (username and password)</li>
</ol>
<h3 id="1-create-liquid-wallet"><a class="header" href="#1-create-liquid-wallet">1. Create Liquid wallet</a></h3>
<p>Create a <code>Signer</code> and backup it's mnemonic/seed.
From the signer get its <code>signer_data</code> using <code>Signer::amp0_signer_data()</code>.</p>
<p>Create a <code>Amp0Connected::new()</code> passing the <code>signer_data</code>.
You now need to authenticate with AMP0 server.
First get the server challenge with <code>Amp0Connected::get_challenge()</code>.
Sign the challenge with <code>Signer::amp0_sign_challenge()</code>.
You can now call <code>Amp0Connected::login()</code> passing the signature.
This function returns a <code>Amp0LoggedIn</code> instance, which can be used to create new AMP0 accounts and watch-only entries.</p>
<h3 id="2-create-an-amp-account"><a class="header" href="#2-create-an-amp-account">2. Create an AMP account</a></h3>
<p>Obtain the number of the next account using <code>Amp0LoggedIn::next_account()</code>.
Use the signer to get the corresponding xpub <code>Signer::amp0_accont_xpub()</code>.
Now you can create a new AMP0 account with <code>Amp0LoggedIn::create_amp0_account()</code>, which returns the AMP ID.</p>
<h3 id="3-create-a-liquid-watch-only"><a class="header" href="#3-create-a-liquid-watch-only">3. Create a Liquid Watch-Only</a></h3>
<p>Choose your your AMP0 Watch-Only credentials <code>username</code> and <code>password</code> and call <code>Amp0LoggedIn::create_watch_only()</code>.</p>
<p>Now that you have mnemonic/seed (or Jade), AMP ID and Watch-Only credentials (username and password), you're ready to use AMP0 with LWK.</p>
<blockquote>
<p>If you're using <code>lwk_node</code>, polyfill the websocket</p>
<pre><code class="language-typescript">const WebSocket = require('ws');
global.WebSocket = WebSocket;
const lwk = require('lwk_node');
</code></pre>
</blockquote>
<custom-tabs category="lang">
<div slot="title">Rust</div>
<section>
<pre><code class="language-rust ignore">use lwk_common::{Amp0Signer, Network};
use lwk_signer::SwSigner;
use lwk_wollet::amp0::blocking::{Amp0, Amp0Connected};

// Create signer and watch only credentials
let network = Network::TestnetLiquid;
let is_mainnet = false;
let (signer, mnemonic) = SwSigner::random(is_mainnet)?;
let username = "&lt;username&gt;";
let password = "&lt;password&gt;";

// Collect signer data
let signer_data = signer.amp0_signer_data()?;

// Connect to AMP0
let amp0 = Amp0Connected::new(network, signer_data)?;

// Obtain and sign the authentication challenge
let challenge = amp0.get_challenge()?;
let sig = signer.amp0_sign_challenge(&amp;challenge)?;

// Login
let mut amp0 = amp0.login(&amp;sig)?;

// Create a new AMP0 account
let pointer = amp0.next_account()?;
let account_xpub = signer.amp0_account_xpub(pointer)?;
let amp_id = amp0.create_amp0_account(pointer, &amp;account_xpub)?;

// Create watch only entries
amp0.create_watch_only(&amp;username, &amp;password)?;

// Use watch only credentials to interact with AMP0
let amp0 = Amp0::new(network, &amp;username, &amp;password, &amp;amp_id)?;</code></pre>
</section>
<div slot="title">Python</div>
<section>
<pre><code class="language-python"># Create signer and watch only credentials
username = "&lt;username&gt;";
password = "&lt;password&gt;";
mnemonic = "&lt;mnemonic&gt;";

network = Network.testnet()
signer = Signer(mnemonic, network)

# Collect signer data
signer_data = signer.amp0_signer_data();

# Connect to AMP0
amp0 = Amp0Connected(network, signer_data);

# Obtain and sign the authentication challenge
challenge = amp0.get_challenge();
sig = signer.amp0_sign_challenge(challenge);

# Login
amp0 = amp0.login(sig);

# Create a new AMP0 account
pointer = amp0.next_account();
account_xpub = signer.amp0_account_xpub(pointer);
amp_id = amp0.create_amp0_account(pointer, account_xpub);

# Create watch only entries
amp0.create_watch_only(username, password);

# Use watch only credentials to interact with AMP0
amp0 = Amp0(network, username, password, amp_id);
</code></pre>
</section>
<div slot="title">Javascript</div>
<section>
<pre><code class="language-typescript">const mnemonic = "&lt;mnemonic&gt;";
const m = new lwk.Mnemonic(mnemonic);
const network = lwk.Network.testnet();
const signer = new lwk.Signer(m, network);
const username = "&lt;username&gt;";
const password = "&lt;password&gt;";

// Collect signer data
const signer_data = signer.amp0SignerData();
// Connect to AMP0
const amp0connected = await new lwk.Amp0Connected(network, signer_data);
// Obtain and sign the authentication challenge
const challenge = await amp0connected.getChallenge();
const sig = signer.amp0SignChallenge(challenge);
// Login
const amp0loggedin = await amp0connected.login(sig);
// Create a new AMP0 account
const pointer = amp0loggedin.nextAccount();
const account_xpub = signer.amp0AccountXpub(pointer);
const amp_id = await amp0loggedin.createAmp0Account(pointer, account_xpub);
// Create watch only entries
await amp0loggedin.createWatchOnly(username, password);
// Use watch only credentials to interact with AMP0
const amp0 = await new lwk.Amp0(network, username, password, amp_id);
</code></pre>
</section>
</custom-tabs>
<h3 id="alternative-setup"><a class="header" href="#alternative-setup">Alternative setup</a></h3>
<p>It's possible to setup an AMP0 account using GDK based apps:</p>
<ol>
<li><a href="https://blockstream.com/app/">Blockstream App</a> (easiest, GUI, mobile, desktop, Jade support), or</li>
<li><a href="https://github.com/Blockstream/green_cli/"><code>green_cli</code></a> (CLI, Jade support), or</li>
<li><a href="https://github.com/blockstream/gdk">GDK</a> directly (fastest, <a href="gdk-amp0.py">example</a>)</li>
</ol>
<h2 id="amp0-daily-operations"><a class="header" href="#amp0-daily-operations">AMP0 daily operations</a></h2>
<p>LWK allows to manage created AMP0 accounts.
You can receive funds, monitor transactions and send to other wallets.</p>
<h3 id="receive"><a class="header" href="#receive">Receive</a></h3>
<p>To receive funds you need an address, you can get addresses with <code>Amp0::address()</code>.</p>
<div class="warning">
⚠️ For AMP0 wallets, do not use <code>Wollet::address()</code> or <code>WolletDescriptor::address()</code>, using them can lead to loss of funds.
AMP0 server only monitors addresses that have been returned by the server.
If you send funds to an address that was not returned by the server, the AMP0 server will not cosign transactions spending that inputs.
Which means that those funds are lost (!), since AMP0 accounts are 2of2.
</div>
<h3 id="monitor"><a class="header" href="#monitor">Monitor</a></h3>
<p>LWK allows to monitor Liquid wallets, including AMP0 accounts.</p>
<p>First you get the AMP0 descriptor with <code>Amp0::wollet_descriptor()</code>.
You then create a wallet with <code>Wollet::new()</code>.</p>
<p>Once you have the AMP0 <code>Wollet</code>, you can get <code>Wollet::transactions()</code>, <code>Wollet::balance()</code> and other information.</p>
<p>LWK wallets needs to be updated with new data from the Liquid blockchain.
First create a blockchain client, for insance <code>EsploraClient::new()</code>.
Then get an update with <code>BlockchainBackend::full_scan_to_index()</code> passing the value returned by <code>Amp0::last_index()</code>.
Finally update the wallet with <code>Wollet::apply_update()</code>.</p>
<div class="warning">
⚠️ For AMP0 wallets, do not sync the wallet with <code>BlockchainBackend::full_scan()</code>, otherwise some funds might not show up.
AMP0 accounts do not have the concept of <code>GAP_LIMIT</code> and they can have several unused address in a row.
The default scanning mechanism when it sees enough unused addresses in a row it stops.
So it can happen that some transactions are not returned, and the wallet balance could be incorrect.
</div>
<h3 id="send-1"><a class="header" href="#send-1">Send</a></h3>
<p>For AMP0 you can follow the standard LWK transaction flow, with few small differences.</p>
<p>Use the <code>TxBuilder</code>, add recipients <code>TxBuilder::add_recipient()</code>, and use the other available methods if needed.</p>
<p>Then instead of using <code>TxBuilder::finish()</code>, use <code>TxBuilder::finish_for_amp0()</code>.
This creates an <code>Amp0Pset</code> which contains the PSET and the <code>blinding_nonces</code>, some extra data needed by the AMP0 cosigner.</p>
<p>Now you need to interact with secret key material (🔑) corresponding to this AMP0 account.
Create a signer, using <code>SWSigner</code> or <code>Jade</code> and sign the PSET with the signer, using <code>Signer::sign()</code>.</p>
<p>Once the PSET is signed, you need to have it cosigned by AMP0.
Construct an <code>Amp0Pset</code> using the signed PSET and the <code>blinding_nonces</code> obtained before.
Call <code>Amp0::sign()</code> passing the signed <code>Amp0Pset</code>.</p>
<p>If all the AMP0 rules are respected, the transaction is cosigned by AMP0 and can be broadcast, e.g. with <code>EsploraClient::broadcast()</code>.</p>
<custom-tabs category="lang">
<div slot="title">Rust</div>
<section>
<pre><code class="language-rust ignore">use lwk_common::{Network, Signer};
use lwk_signer::SwSigner;
use lwk_wollet::amp0::{blocking::Amp0, Amp0Pset};
use lwk_wollet::{clients::blocking::EsploraClient, ElementsNetwork, Wollet};

// Signer
let mnemonic = "&lt;mnemonic&gt;";
// AMP0 Watch-Only credentials
let username = "&lt;username&gt;";
let password = "&lt;password&gt;";
// AMP ID (optional)
let amp_id = "";

// Create AMP0 context
let network = Network::TestnetLiquid;

let mut amp0 = Amp0::new(network, username, password, amp_id)?;

// Create AMP0 Wollet
let wd = amp0.wollet_descriptor();
let mut wollet = Wollet::without_persist(ElementsNetwork::LiquidTestnet, wd)?;

// Get a new address
let addr = amp0.address(None);

// Update the wallet with (new) blockchain data
let url = "https://blockstream.info/liquidtestnet/api";
let mut client = EsploraClient::new(url, ElementsNetwork::LiquidTestnet)?;
if let Some(update) = client.full_scan_to_index(&amp;wollet, amp0.last_index())? {
    wollet.apply_update(update)?;
}

// Get balance
let balance = wollet.balance()?;

// Construct a PSET sending LBTC back to the wallet
let amp0pset = wollet
    .tx_builder()
    .drain_lbtc_wallet()
    .finish_for_amp0()?;
let mut pset = amp0pset.pset().clone();
let blinding_nonces = amp0pset.blinding_nonces();

// User signs the PSET
let is_mainnet = false;
let signer = SwSigner::new(mnemonic, is_mainnet)?;
let sigs = signer.sign(&amp;mut pset)?;
assert!(sigs &gt; 0);

// Reconstruct the Amp0 PSET with the PSET signed by the user
let amp0pset = Amp0Pset::new(pset, blinding_nonces.to_vec())?;

// AMP0 signs
let tx = amp0.sign(&amp;amp0pset)?;

// Broadcast the transaction
let txid = client.broadcast(&amp;tx)?;</code></pre>
</section>
<div slot="title">Python</div>
<section>
<pre><code class="language-python"># Signer
mnemonic = "&lt;mnemonic&gt;";
# AMP0 Watch-Only credentials
username = "&lt;username&gt;";
password = "&lt;password&gt;";
# AMP ID (optional)
amp_id = "";

# Create AMP0 context
network = Network.testnet()

amp0 = Amp0(network, username, password, amp_id);

# Create AMP0 Wollet
wollet_descriptor = amp0.wollet_descriptor()
wollet = Wollet(network, wollet_descriptor, None)

# Get a new address
addr = str(amp0.address(None).address());

# Update the wallet with (new) blockchain data
url = "https://waterfalls.liquidwebwallet.org/liquidtestnet/api";
client = EsploraClient.new_waterfalls(url, network)
last_index = amp0.last_index()
update = client.full_scan_to_index(wollet, last_index)
wollet.apply_update(update)

# Get balance
balance = wollet.balance()

# Construct a PSET sending LBTC back to the wallet
b = network.tx_builder()
b.drain_lbtc_wallet()  # send all to self
amp0pset = b.finish_for_amp0(wollet)

# User signs the PSET
signer = Signer(Mnemonic(mnemonic), network)
pset = amp0pset.pset()
pset = signer.sign(pset)

# Reconstruct the Amp0 PSET with the PSET signed by the user
amp0pset = Amp0Pset(pset, amp0pset.blinding_nonces())

# AMP0 signs
tx = amp0.sign(amp0pset)

# Broadcast the transaction
txid = client.broadcast(tx)
</code></pre>
</section>
<div slot="title">Javascript</div>
<section>
<pre><code class="language-typescript">const mnemonic = "&lt;mnemonic&gt;";
const m = new lwk.Mnemonic(mnemonic);
const network = lwk.Network.testnet();
const signer = new lwk.Signer(m, network);
const username = "&lt;username&gt;";
const password = "&lt;password&gt;";
const amp_id = "";

// Create AMP0 object
const amp0 = await lwk.Amp0.newTestnet(username, password, amp_id);

// Get an address
const addrResult = await amp0.address(1);

// Create wollet
const wollet = amp0.wollet();

// Sync the wallet
const url = "https://waterfalls.liquidwebwallet.org/liquidtestnet/api";
const client = new lwk.EsploraClient(network, url, true, 4, false);

const last_index = amp0.lastIndex();
const update = await client.fullScanToIndex(wollet, last_index);
if (update) {
    wollet.applyUpdate(update);
}

// Get the wallet transactions
const txs = wollet.transactions();

// Get the balance
const balance = wollet.balance();

// Create a (redeposit) transaction
var b = network.txBuilder();
b = b.drainLbtcWallet();
const amp0pset = b.finishForAmp0(wollet);

// Sign with the user key
const pset = amp0pset.pset();
const signed_pset = signer.sign(pset);

// Ask AMP0 to cosign
const amp0pset_signed = new lwk.Amp0Pset(signed_pset, amp0pset.blindingNonces());
const tx = await amp0.sign(amp0pset_signed);

// Broadcast
const txid = await client.broadcastTx(tx);
</code></pre>
</section>
</custom-tabs>
<h2 id="examples"><a class="header" href="#examples">Examples</a></h2>
<p>We provide a few examples on how to integrate use AMP0 with LWK:</p>
<ul>
<li><a href="https://liquidwebwallet.org">liquidwebwallet.org</a> integrates AMP0 using WASM</li>
<li>Rust tests in <a href="../lwk_wollet/src/amp0.rs">amp0.rs</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="lwk-structure"><a class="header" href="#lwk-structure">LWK Structure</a></h1>
<p>LWK functionalities are split into different component crates that might be useful independently.</p>
<ul>
<li><a href="../lwk_cli"><code>lwk_cli</code></a>: a CLI tool to use LWK wallets.</li>
<li><a href="../lwk_wollet"><code>lwk_wollet</code></a>: library for watch-only wallets;
specify a CT descriptor, generate new addresses, get balance,
create PSETs and other actions.</li>
<li><a href="../lwk_signer"><code>lwk_signer</code></a>: interact with Liquid signers
to get your PSETs signed.</li>
<li><a href="../lwk_jade"><code>lwk_jade</code></a>: unlock Jade, get xpubs,
register multisig wallets, sign PSETs and more.</li>
<li><a href="../lwk_bindings"><code>lwk_bindings</code></a>: use LWK from other languages.</li>
<li><a href="../lwk_wasm"><code>lwk_wasm</code></a>: use LWK from WebAssembly.</li>
<li>and more:
common or ancillary components (<a href="../lwk_common"><code>lwk_common</code></a>,
<a href="../lwk_rpc_model"><code>lwk_rpc_model</code></a>, <a href="../lwk_tiny_rpc"><code>lwk_tiny_rpc</code></a>,
<a href="../lwk_app"><code>lwk_app</code></a>),
future improvements (<a href="../lwk_hwi"><code>lwk_hwi</code></a>),
testing infrastructure (<a href="../lwk_test_util"><code>lwk_test_util</code></a>,
<a href="../lwk_containers"><code>lwk_containers</code></a>)</li>
</ul>
<p>For instance, mobile app devs might be interested mainly in
<code>lwk_bindings</code>, <code>lwk_wollet</code> and <code>lwk_signer</code>.
While backend developers might want to directly use <code>lwk_cli</code>
in their systems.</p>
<p>Internal crate dependencies are shown in this diagram: an arrow indicates "depends on" (when dotted the dependency is feature-activated, when blue is a dev-dependency):</p>
<p><img src="./dep-tree.svg" alt="Dep tree" /></p>
<p>(generated with <code>cargo depgraph --workspace-only --dev-deps</code>)</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="users-of-lwk"><a class="header" href="#users-of-lwk">Users of LWK</a></h1>
<p>This section showcases a series of projects that are built on LWK or its components.</p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Description</th><th>Type</th><th>Language</th></tr></thead><tbody>
<tr><td><a href="https://liquidtestnet.com">Liquidtestnet.com</a></td><td>Testnet Faucet</td><td>Server</td><td>Python</td></tr>
<tr><td><a href="https://liquidwebwallet.org">Liquidwebwallet.org</a></td><td>Browser wallet</td><td>Wallet</td><td>Wasm</td></tr>
<tr><td><a href="https://amp2.testnet.blockstream.com/info/spec">AMP2</a></td><td>Registered Assets</td><td>Server</td><td>Closed source</td></tr>
<tr><td><a href="https://github.com/breez/breez-sdk-liquid">Breeze SDK Liquid</a></td><td>Lightning swaps</td><td>SDK</td><td>Rust</td></tr>
<tr><td><a href="https://boltz.exchange/">Boltz</a></td><td>Atomic swaps</td><td>Server</td><td>Go</td></tr>
<tr><td><a href="https://aqua.net/">Aqua</a></td><td>Atomic swaps</td><td>Wallet</td><td>Dart</td></tr>
<tr><td><a href="https://wallet.bullbitcoin.com/">Bull Bitcoin</a></td><td>Atomic swaps</td><td>Wallet</td><td>Dart</td></tr>
<tr><td><a href="https://blitz-wallet.com/">Blitz Wallet</a></td><td>Atomic swaps</td><td>Wallet</td><td>Javascript</td></tr>
<tr><td><a href="https://www.peerswap.dev/">Peerswap</a></td><td>LN Balancing</td><td>Server</td><td>Go</td></tr>
<tr><td><a href="https://www.arealayer.net/projects#h.kk9ofahkprw7">AreaLayer FireBolt wallet</a></td><td>Wallet</td><td>Wallet</td><td>TypeScript</td></tr>
<tr><td><a href="https://bancolibre.com/">Banco Libre</a></td><td>Browser wallet</td><td>Wallet</td><td>Wasm</td></tr>
<tr><td><a href="https://breez.technology/">Misty Breeze</a></td><td>Lightning wallet</td><td>Wallet</td><td>Dart</td></tr>
<tr><td><a href="https://blog.onionmill.com/">Onion Mill - StashPay</a></td><td>Lightning wallet</td><td>Wallet</td><td></td></tr>
<tr><td><a href="https://github.com/dev4bitcoin/psetgui/">PSET GUI</a></td><td>PSET Analyzer</td><td>Tool</td><td>JavaScript</td></tr>
<tr><td><a href="https://www.satsails.com/">Satsails</a></td><td>Wallet</td><td>Wallet</td><td>Dart</td></tr>
<tr><td><a href="https://shopstr.store/">Shopstr</a></td><td>Nostr Marketplace</td><td>Server</td><td>TypeScript</td></tr>
</tbody></table>
</div>
<p>Feel free to open a PR to add or remove your product.</p>
<h2 id="liquidtestnetcom"><a class="header" href="#liquidtestnetcom">Liquidtestnet.com</a></h2>
<p><a href="https://liquidtestnet.com">Liquidtestnet.com</a> provides a several utilities to interact with Liquid testnet.
It also has a testnet faucet which distributes testnet assets (LBTC, standard assets and AMP0, AMP2 assets).</p>
<p>The faucet is built using LWK python wheels.</p>
<p>Liquidtestnet.com is open source, source available in the <a href="https://github.com/valerio-vaccaro/liquidtestnet.com">Github repository</a>.</p>
<h2 id="liquidwebwalletorg"><a class="header" href="#liquidwebwalletorg">Liquidwebwallet.org</a></h2>
<p><a href="https://liquidwebwallet.org">Liquidwebwallet.org</a> is a companion app for Liquid running in the browser.
The website allows the use of read-only wallets or hardware wallets such as Jade or Ledger to access one's wallet, view the balance, create transactions, create issuance, reissuance, and burn transactions.</p>
<p>The wallet is built using <a href="https://www.npmjs.com/package/lwk_wasm">LWK_wasm</a>.</p>
<p>Liquidwebwallet.org is open source, source available in the <a href="https://github.com/RCasatta/liquid-web-wallet">Github repository</a></p>
<h2 id="amp2"><a class="header" href="#amp2">AMP2</a></h2>
<p><a href="https://amp2.testnet.blockstream.com/info/spec">AMP2</a> is a platform able to issue and manage digital assets on the Liquid Network with flexible API.
The platform allows for the management of the entire token lifecycle, enabling the control and authorization of each individual operation.</p>
<p>AMP2 uses LWK internally.</p>
<p>AMP2 is closed source.</p>
<h2 id="breeze-sdk-liquid"><a class="header" href="#breeze-sdk-liquid">Breeze SDK Liquid</a></h2>
<p>The <a href="https://github.com/breez/breez-sdk-liquid">Breeze SDK Liquid</a> provides developers with a end-to-end solution for integrating self-custodial Lightning payments into their apps and services.</p>
<p>The SDK use LWK as internal liquid wallet and signer.</p>
<p>Breeze SDK Liquid is open source, source available in the <a href="https://github.com/breez/breez-sdk-liquid">Github repository</a></p>
<h2 id="boltz"><a class="header" href="#boltz">Boltz</a></h2>
<p><a href="https://boltz.exchange/">Boltz</a> the Non-Custodial Bitcoin Bridge able to swap between different Bitcoin layers.</p>
<p>The SDK use LWK as internal liquid wallet and signer.</p>
<p>Boltz is open source, source available in the <a href="https://github.com/BoltzExchange/boltz-client">Github repository</a></p>
<h2 id="aqua"><a class="header" href="#aqua">Aqua</a></h2>
<p><a href="https://aqua.net/">Aqua</a> AQUA is a free, open-source wallet for iOS and Android.</p>
<p>The app use LWK in the backend.</p>
<p>Aqua is open source, source available in the <a href="https://github.com/AquaWallet/aqua-wallet">Github repository</a></p>
<h2 id="bull-bitcoin"><a class="header" href="#bull-bitcoin">Bull Bitcoin</a></h2>
<p><a href="https://wallet.bullbitcoin.com/">Bull Bitcoin</a> is a mobile wallet with Bitcoin, Liquid and lightning support.</p>
<p>Bull Bitcoin uses LWK for its Liquid wallet.</p>
<p>Bull Bitcoin is open source, source available in the <a href="https://github.com/SatoshiPortal/bullbitcoin-mobile">Github repository</a></p>
<h2 id="blitz-wallet"><a class="header" href="#blitz-wallet">Blitz Wallet</a></h2>
<p><a href="https://blitz-wallet.com/">Blitz Wallet</a> is a react native wallet.</p>
<p>The app is based on Breeze SDK Liquid.</p>
<p>Blitz Wallet is open source, source available in the <a href="https://github.com/BlitzWallet/BlitzWallet">Github repository</a></p>
<h2 id="peerswap"><a class="header" href="#peerswap">Peerswap</a></h2>
<p><a href="https://www.peerswap.dev/">Peerswap</a> Atomic swaps for rebalancing Lightning channels.</p>
<p>The app use LWK as internal liquid wallet and signer.</p>
<p>Peerswap is open source, source available in the <a href="https://github.com/ElementsProject/peerswap">Github repository</a></p>
<h2 id="arealayer-firebolt-wallet"><a class="header" href="#arealayer-firebolt-wallet">AreaLayer FireBolt wallet</a></h2>
<p>|<a href="https://www.arealayer.net/projects#h.kk9ofahkprw7">AreaLayer FireBolt wallet</a> is a react native wallet.</p>
<p>The app is based on Breeze SDK Liquid.</p>
<p>AreaLayer FireBolt wallet is open source, source available in the <a href="https://github.com/AreaLayer/firebolt-react-native">Github repository</a></p>
<h2 id="banco-libre"><a class="header" href="#banco-libre">Banco Libre</a></h2>
<p><a href="https://bancolibre.com/">Banco Libre</a> is a web wallet using LWK_wasm.</p>
<p>The app use LWK_wasm as internal liquid wallet and signer.</p>
<p>Banco Libre is open source, source available in the <a href="https://github.com/kipu-org/banco-client">Github repository</a></p>
<h2 id="misty-breeze"><a class="header" href="#misty-breeze">Misty Breeze</a></h2>
<p><a href="https://breez.technology/">Misty Breeze</a> is a flutter app based on Breez SDK Liquid.</p>
<p>The app is based on Breeze SDK Liquid.</p>
<p>Misty Breeze is open source, source available in the <a href="https://github.com/breez/misty-breez">Github repository</a></p>
<h2 id="onion-mill---stashpay"><a class="header" href="#onion-mill---stashpay">Onion Mill - StashPay</a></h2>
<p><a href="https://blog.onionmill.com/">Onion Mill - StashPay</a> is a  minimalist Bitcoin wallet based on Breeze SDK Liquid.</p>
<p>The app is based on Breeze SDK Liquid.</p>
<p>Onion Mill - StashPay is open source, source available in the <a href="https://github.com/onionmill/stashpay-bin">Github repository</a></p>
<h2 id="pset-gui"><a class="header" href="#pset-gui">PSET GUI</a></h2>
<p><a href="https://github.com/dev4bitcoin/psetgui/">PSET GUI</a> is a user-friendly application designed for analyzing and signing PSETs.</p>
<p>The app use LWK_wasm as internal liquid wallet and signer.</p>
<p>PSET GUI is open source, source available in the <a href="https://github.com/dev4bitcoin/psetgui/">Github repository</a></p>
<h2 id="satsails"><a class="header" href="#satsails">Satsails</a></h2>
<p><a href="https://www.satsails.com/">Satsails</a> is a self-custodial Bitcoin and Liquid wallet with support for stablecoins.</p>
<p>The app use LWK_wasm as internal liquid wallet and signer.</p>
<p>Satsails is open source, source available in the <a href="https://github.com/Satsails/Satsails">Github repository</a></p>
<h2 id="shopstr"><a class="header" href="#shopstr">Shopstr</a></h2>
<p><a href="https://shopstr.store/">Shopstr</a> is a global, permissionless Nostr marketplace for Bitcoin commerce.</p>
<p>WIP for <a href="https://github.com/shopstr-eng/shopstr/issues/74">Liquid integration</a></p>
<p>Shopstr is open source, source available in the <a href="https://github.com/shopstr-eng/">Github repository</a></p>
<h1 id="unknown-users"><a class="header" href="#unknown-users">Unknown users</a></h1>
<p>There may be many other users of the libraries who are currently unknown or not publicly disclosed</p>
<p>The libraries' license allows their integration into both open-source and closed-source solutions.These users can leverage lwk to:</p>
<ul>
<li>Develop wallets and online services for asset management,</li>
<li>Create swap services,</li>
<li>Issue, reissue, and burn assets.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="lwk-history"><a class="header" href="#lwk-history">LWK History</a></h1>
<p>BEWallet was <a href="https://github.com/LeoComandini/BEWallet/">originally</a>
an Elements/Liquid wallet library written in Rust to develop
prototypes and experiments.</p>
<p>BEWallet was based on <a href="https://github.com/Blockstream/gdk">Blockstream's GDK</a>.
Essentially some GDK Rust pieces were moved to this project.</p>
<p>This was used as the starting point for the Liquid Wallet Kit project.
Parts that were not necessary have been dropped,
many things have been polished, and new features have been added.</p>
<p>The codebase has been entirely re-written, and now it has
almost no similarity with the original code.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="mermaid.min.js"></script>
        <script src="mermaid-init.js"></script>
        <script src="tabs.js"></script>

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>


    </div>
    </body>
</html>
