<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>LWK Documentation</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="styles.css">


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>‚Üê</kbd> or <kbd>‚Üí</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">LWK Documentation</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/blockstream/lwk" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="about-lwk"><a class="header" href="#about-lwk">About LWK</a></h1>
<p>The Liquid Wallet Kit (LWK) is a comprehensive toolkit that empowers developers to build a new generation of wallets and applications for the Liquid Network. Instead of grappling with the intricate, low-level details of Liquid's confidential transactions, asset management, and cryptographic primitives, LWK provides a powerful set of foundational building blocks. These tools are functional and secure, helping you build your projects with confidence.</p>
<p>LWK's primary goal is to abstract away complexity by handling the most challenging aspects of Liquid development, such as:</p>
<ul>
<li><strong>Confidential Transactions</strong> handling, which automatically obscures amounts and asset types to maintain user privacy.</li>
<li><strong>Asset issuance and management</strong>, providing a seamless way to create and interact with new digital assets.</li>
<li><strong>Signing Liquid transactions</strong>, allowing for interaction with software signers and hardware wallets.</li>
</ul>
<p>By providing these building blocks, LWK liberates developers from building Liquid functionality from scratch. This allows them to significantly accelerate development time and focus on creating unique, value-added features for their specific use cases, whether it's building a mobile wallet, integrating Liquid in an exchange, or developing a DeFi application. Ultimately, LWK is the definitive, go-to library for anyone committed to innovating on the Liquid Network.</p>
<h2 id="example-single-sig-mobile-wallet"><a class="header" href="#example-single-sig-mobile-wallet">Example: single-sig mobile wallet</a></h2>
<p>This example application showcases how the Liquid Wallet Kit (LWK) simplifies the development of a single-signature mobile wallet. The two diagrams below illustrate the key user flows: Wallet Creation and Transaction Management. LWK handles the complex, low-level interactions with the Liquid blockchain and cryptographic operations, allowing the application to focus on the user interface and experience.</p>
<h3 id="wallet-creation"><a class="header" href="#wallet-creation">Wallet Creation</a></h3>
<p>The mobile app starts by creating a new software <code>signer</code> and helps the user back up the corresponding BIP39 mnemonic. From this signer, the app extracts the <code>xpub</code> to derive a single-signature <a href="https://github.com/ElementsProject/ELIPs/blob/main/elip-0150.mediawiki">CT descriptor</a> (e.g., <code>ct(slip77(...),elwpkh([...]xpub/&lt;0;1&gt;/*))</code>).</p>
<p>This CT descriptor is then used to initialize a <code>wollet</code>, which is LWK's watch-only wallet. The <code>wollet</code> allows the app to fetch addresses, transactions, and the current balance to display in the user interface.</p>
<p>When the app is opened, it uses a <code>client</code> to sync the wollet with the latest blockchain information. This ensures the wallet data is up-to-date.</p>
<pre class="mermaid">flowchart TD
    Signer(Signer üîë)
    Wollet(&quot;Wollet üëÄ&lt;br&gt;(descriptor)&quot;)
    Client(Client üåê)
    App((üì±))
    Signer --&gt;|Xpub| Wollet 
    Client --&gt;|Blockchain Update| Wollet
    Wollet --&gt;|Addresses, Txs, Balance| App
</pre>
<h3 id="transaction-management"><a class="header" href="#transaction-management">Transaction Management</a></h3>
<p>The mobile app enables users to send funds by allowing them to specify the amount, asset, and destination address. The <code>wollet</code> then takes this information to create an unsigned transaction, which is encoded in the <a href="https://github.com/ElementsProject/ELIPs/blob/main/elip-0150.mediawiki">PSET</a> format.</p>
<p>The PSET is passed to the <code>signer</code>, which uses its private keys to sign the transaction. Once the PSET is signed, it's finalized into a complete transaction, which the <code>client</code> then broadcasts to the Liquid Network.</p>
<pre class="mermaid">flowchart TD
    Signer(Signer üîë)
    Wollet(&quot;Wollet üëÄ&lt;br&gt;(descriptor)&quot;)
    Client(Client üåê)
    App((üì±))
    App --&gt;|Create TX| Wollet
    Wollet --&gt;|Unsigned PSET| Signer 
    Signer --&gt;|Signed PSET| Wollet 
    Wollet --&gt;|Broadcast TX| Client
</pre>
<h3 id="remarks"><a class="header" href="#remarks">Remarks</a></h3>
<p>This simple example highlights the core responsibilities of each LWK component:</p>
<ul>
<li><strong>Signer</strong> üîë: Manages private keys and handles all signing operations.</li>
<li><strong>Wollet</strong> üëÄ: Provides a watch-only view of the wallet, deriving addresses and tracking transactions and balances without holding any private keys.</li>
<li><strong>Client</strong> üåê: Fetch blockchain data from the Liquid Network to update the <code>wollet</code>.</li>
</ul>
<h2 id="key-features"><a class="header" href="#key-features">Key Features</a></h2>
<p>LWK allows to build more complex applications and products by leveraging its wide range of features:</p>
<ul>
<li><input disabled="" type="checkbox" checked=""/>
Send and receive LBTC</li>
<li><input disabled="" type="checkbox" checked=""/>
Send and receive Liquid Issued Assets (e.g. USDT)</li>
<li><input disabled="" type="checkbox" checked=""/>
Send and receive AMP assets (e.g. BMN)</li>
<li><input disabled="" type="checkbox" checked=""/>
Software signers</li>
<li><input disabled="" type="checkbox" checked=""/>
Hardware wallets support (Jade)</li>
<li><input disabled="" type="checkbox" checked=""/>
Watch-Only view with CT descriptors</li>
<li><input disabled="" type="checkbox" checked=""/>
Single-sig</li>
<li><input disabled="" type="checkbox" checked=""/>
Generic Multisig</li>
<li><input disabled="" type="checkbox" checked=""/>
Multi-language support (Swift, Kotlin, Javascript, Typescript, Wasm, React Native, Go, C#, Rust, Flutter/Dart, Python)</li>
</ul>
<p>For a more complete and detailed list of LWK features see <a href="features.html">here</a>.</p>
<h2 id="get-started"><a class="header" href="#get-started">Get started</a></h2>
<p><a href="install.html">Install LWK</a> and go through our <a href="basics.html">tutorial</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="features"><a class="header" href="#features">Features</a></h1>
<ul>
<li><strong>Watch-Only</strong> wallet support: using Liquid descriptors, better known as
<a href="https://github.com/ElementsProject/ELIPs/blob/main/elip-0150.mediawiki">CT descriptors</a>.</li>
<li><strong>PSET</strong> based: transactions are shared and processed using the
<a href="https://github.com/ElementsProject/elements/blob/1fcf0cf2323b7feaff5d1fc4c506fff5ec09132e/doc/pset.mediawiki">Partially Signed Elements Transaction</a> format.</li>
<li><a href="https://github.com/Blockstream/electrs"><strong>Electrum</strong>, <strong>Esplora</strong></a> and <a href="https://github.com/RCasatta/waterfalls">Waterfalls</a>:
no need to run and sync a full Liquid node or rely on closed source servers.</li>
<li><strong>Asset issuance</strong>, <strong>reissuance</strong> and <strong>burn</strong> support: manage the lifecycle
of your Issued Assets with a lightweight client.</li>
<li><strong>Generic multisig</strong> wallets: create a wallet controlled by
any combination of hardware or software signers, with a user
specified quorum.</li>
<li><strong>Hardware signer</strong> support: receive, issue, reissue and burn L-BTC and
Issued Assets with your hardware signer, using singlesig or multisig
wallets (currently <a href="https://blockstream.com/jade/"><strong>Jade</strong></a> only, with more coming soon).</li>
<li><strong>Multi Language</strong> support: Swift, Kotlin, Javascript, Typescript, WASM, React Native, Go, C#, Rust, Flutter/Dart and Python.</li>
<li><strong>Liquid Atomic Swaps</strong>: using <a href="https://blog.blockstream.com/liquidex-2-step-atomic-swaps-on-the-liquid-network/">LiquiDEX</a>.</li>
<li><strong>Blockstream AMP</strong> support: send and receive asset issued with the <a href="https://blockstream.com/amp/">Blockstream Asset Management Platform</a>.</li>
<li><strong>...and more!</strong></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="installing-lwk"><a class="header" href="#installing-lwk">Installing LWK</a></h1>
<p>LWK is available for several languages.</p>
<h2 id="rust"><a class="header" href="#rust">Rust</a></h2>
<p>You can use the crates released on <a href="https://crates.io">crates.io</a></p>
<pre><code class="language-rust ignore">[dependencies]
lwk_wollet = "0.11.0"
lwk_signer = "0.11.0"
lwk_common = "0.11.0"</code></pre>
<h2 id="python"><a class="header" href="#python">Python</a></h2>
<p>You can use the official python package: <a href="https://pypi.org/project/lwk/">lwk</a></p>
<pre><code class="language-shell ignore">pip install lwk
</code></pre>
<h2 id="javascripttypescript-wasm"><a class="header" href="#javascripttypescript-wasm">Javascript/Typescript (Wasm)</a></h2>
<h3 id="wasm-module"><a class="header" href="#wasm-module">Wasm module</a></h3>
<p>Install LWK</p>
<pre><code class="language-shell ignore">npm install lwk_wasm
</code></pre>
<p>Import LWK</p>
<pre><code class="language-typescript ignore">const lwk = require('lwk_wasm');
</code></pre>
<h3 id="node-module"><a class="header" href="#node-module">Node module</a></h3>
<p>Install LWK</p>
<pre><code class="language-shell ignore">npm install lwk_node
</code></pre>
<p>Import LWK</p>
<pre><code class="language-typescript ignore">const lwk = require('lwk_node');
</code></pre>
<h2 id="iosswift"><a class="header" href="#iosswift">iOS/Swift</a></h2>
<h2 id="androidkotlin"><a class="header" href="#androidkotlin">Android/Kotlin</a></h2>
<h2 id="react-native"><a class="header" href="#react-native">React Native</a></h2>
<h2 id="go"><a class="header" href="#go">Go</a></h2>
<h2 id="c"><a class="header" href="#c">C#</a></h2>
<pre><code class="language-shell ignore">dotnet add package LiquidWalletKit --version 0.8.2
</code></pre>
<p>Please open an issue if you need a more recent version</p>
<h2 id="flutterdart"><a class="header" href="#flutterdart">Flutter/Dart</a></h2>
<div style="break-before: page; page-break-before: always;"></div><h1 id="lwk-basics"><a class="header" href="#lwk-basics">LWK Basics</a></h1>
<p>LWK is a versatile library designed for a wide range of Liquid applications, from server integrations and mobile wallets to secure, standalone offline signers. Its flexibility allows developers to find the perfect balance between security, performance, and user experience for their specific needs.</p>
<h2 id="how-lwk-works-a-step-by-step-walkthrough"><a class="header" href="#how-lwk-works-a-step-by-step-walkthrough">How LWK Works: A Step-by-Step Walkthrough</a></h2>
<p>This guide will walk you through the core components of LWK and show how they interact to manage and sign Liquid transactions. We'll cover the following steps in detail:</p>
<ul>
<li><strong>Create a Signer</strong>: First you will see how LWK manages private keys.</li>
<li><strong>Create a Wallet</strong>: Next, you'll create a wallet to track your funds and handle your addresses.</li>
<li><strong>Update the Wallet</strong>: You'll learn how to sync your wallet with blockchain data to get an accurate view of your balances.</li>
<li><strong>Create a Transaction</strong>: This step covers how to build a new transaction, specifying inputs and outputs.</li>
<li><strong>Sign a Transaction</strong>: Here, we'll demonstrate how to use the private keys from your signer to sign a transaction.</li>
<li><strong>Broadcast a Transaction</strong>: Finally, you'll learn how to send your signed transaction to the Liquid network.</li>
</ul>
<hr />
<p>Next: <a href="signer.html">Create a LWK signer</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="signers"><a class="header" href="#signers">Signers</a></h1>
<p>In LWK, the management of private keys is delegated to a specialized component called <strong>Signer</strong>.</p>
<p>The primary tasks of a signer are:</p>
<ul>
<li>provide <code>xpub</code>s, which are used to create wallets</li>
<li>sign transactions</li>
</ul>
<h2 id="types-of-signers"><a class="header" href="#types-of-signers">Types of Signers</a></h2>
<p>LWK has two signer types:</p>
<ul>
<li><strong>Software Signers</strong>: store the private keys in memory. This is the simplest signer to integrate and interact with.</li>
<li><strong>Hardware Signers</strong>: LWK provides specific integrations for hardware wallets, such as the Blockstream Jade. These signers keep the private keys completely isolated from the computer.</li>
</ul>
<p>While hardware signers are inherently more secure, LWK's design allows you to enhance the security of software signers as well. For example, a software signer can be run on an isolated machine or a mobile app might store the mnemonic (seed) encrypted, only decrypting it when a signature is required.</p>
<p>This guide will focus on software signers. For more details on hardware signers, please see the <a href="jade.html">Jade documentation</a>.</p>
<h2 id="create-signer"><a class="header" href="#create-signer">Create Signer</a></h2>
<p>To create a signer you need a mnemonic.
You can generate a new one with <code>bip39::Mnemonic::generate()</code>.
Then you can create a software signer with <code>SwSigner::new()</code>.</p>
<custom-tabs category="lang">
<div slot="title">Rust</div>
<section>
<pre><code class="language-rust ignore">use lwk_signer::{bip39::Mnemonic, SwSigner};

let mnemonic = Mnemonic::generate(12)?;
let is_mainnet = false;

let signer = SwSigner::new(&amp;mnemonic.to_string(), is_mainnet)?;</code></pre>
</section>
<div slot="title">Python</div>
<section>
<pre><code class="language-python">mnemonic = Mnemonic.from_random(12)
network = Network.testnet()
signer = Signer(mnemonic, network)
</code></pre>
</section>
<div slot="title">Javascript</div>
<section>
<pre><code class="language-typescript">const mnemonic = lwk.Mnemonic.fromRandom(12);
const network = lwk.Network.testnet();
const signer = new lwk.Signer(mnemonic, network);
</code></pre>
</section>
</custom-tabs>
<h2 id="get-xpub"><a class="header" href="#get-xpub">Get Xpub</a></h2>
<p>Once you have a signer you need to get some an extended public key (<code>xpub</code>),
which can be used to create a wallet that requires signature from the signer.</p>
<p>The xpub is obtained with <code>Signer::keyorigin_xpub()</code>, which also includes the keyorigin information: signer fingerprint and derivation path from master key to the returned xpub, e.g. <code>[ffffffff/84h/1h/0h]xpub...</code>.</p>
<custom-tabs category="lang">
<div slot="title">Rust</div>
<section>
<pre><code class="language-rust ignore">let bip = lwk_common::Bip::Bip84;
let xpub = signer.keyorigin_xpub(bip, is_mainnet);</code></pre>
</section>
<div slot="title">Python</div>
<section>
<pre><code class="language-python">xpub = signer.keyorigin_xpub(Bip.new_bip84())
</code></pre>
</section>
<div slot="title">Javascript</div>
<section>
<pre><code class="language-typescript">const xpub = signer.keyoriginXpub(lwk.Bip.bip84());
</code></pre>
</section>
</custom-tabs>
<p>For particularly simple cases, such as single sig, you can get the CT descriptor directly from the signer, for instance using <code>Signer::wpkh_slip77_descriptor()</code>.</p>
<hr />
<p>Next: <a href="wollet.html">Watch-Only Wallets</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="watch-only-wallets"><a class="header" href="#watch-only-wallets">Watch-Only Wallets</a></h1>
<p>In LWK, the core functions of a wallet are split between two components for enhanced security: <strong>Signers</strong> manage private keys, while the <strong>Wollet</strong> handles everything else.</p>
<p>The term "Wollet" is not a typo; it stands for "Watch-Only wallet." A wollet provides view-only access, allowing you to generate addresses and see your balance without ever handling private keys. This design is crucial for security, as it keeps your private keys isolated.</p>
<p>A LWK wollet can perform the following operations:</p>
<ul>
<li>Generate addresses</li>
<li>List transactions</li>
<li>Get balance</li>
<li>Create transactions (but not sign them)</li>
</ul>
<h2 id="ct-descriptors"><a class="header" href="#ct-descriptors">CT descriptors</a></h2>
<p>A Wollet is defined by a <a href="https://github.com/ElementsProject/ELIPs/blob/main/elip-0150.mediawiki">CT descriptor</a>, which consists in a Bitcoin descriptor plus the descriptor blinding key.</p>
<p>In the previous section, we saw how to generate a single sig CT descriptor from a signer with <code>Signer::wpkh_slip77_descriptor()</code>, which returns something like:</p>
<pre><code class="language-ignore">ct(slip77(...),elwpkh([ffffffff/84h/1h/0h]xpub...))
</code></pre>
<ul>
<li><code>ct(...,...)</code></li>
<li><code>slip77(...)</code> the descriptor blinding key</li>
<li><code>el</code> the "Elements" prefix</li>
<li><code>wpkh([ffffffff/84h/1h/0h]xpub...)</code> the "Bitcoin descriptor", with</li>
</ul>
<p>The CT descriptors defines the wallet spending conditions. In this case it requires a single signature from a specific signer.</p>
<p>LWK supports more complex spending conditions, such as <a href="multisig.html">multisig</a>.</p>
<h2 id="create-a-wollet"><a class="header" href="#create-a-wollet">Create a Wollet</a></h2>
<p>From the CT descriptor, you need to generate a <code>WolletDescriptor</code>. Calling <code>WolletDescriptor::from_str()</code> will perform some basic validation of the descriptor, and fails if the descriptor is not supported by LWK.</p>
<p>Once you have a <code>WolletDescriptor</code> you can create a <code>Wollet</code> using either <code>Wollet::without_persist()</code> (keeps wallet data in memory) or <code>Wollet::with_fs_persist()</code> (stores wallet data on filesystem).</p>
<p>LWK also allows <code>Wollet</code>s to have a <a href="persister.html">custom persister</a>.</p>
<custom-tabs category="lang">
<div slot="title">Rust</div>
<section>
<pre><code class="language-rust ignore">use lwk_wollet::{ElementsNetwork, Wollet, WolletDescriptor};

let desc = signer.wpkh_slip77_descriptor()?;
let wd = WolletDescriptor::from_str(&amp;desc)?;
let network = ElementsNetwork::LiquidTestnet;
let mut wollet = Wollet::without_persist(network, wd)?;</code></pre>
</section>
<div slot="title">Python</div>
<section>
<pre><code class="language-python">desc = signer.wpkh_slip77_descriptor()
wollet = Wollet(network, desc, datadir=None)
</code></pre>
</section>
<div slot="title">Javascript</div>
<section>
<pre><code class="language-typescript">const desc = signer.wpkhSlip77Descriptor();
const wollet = new lwk.Wollet(network, desc);
</code></pre>
</section>
</custom-tabs>
<h2 id="generate-addresses"><a class="header" href="#generate-addresses">Generate Addresses</a></h2>
<p>You can generate a wallet confidential address with <code>Wollet::address()</code>.</p>
<p>This address can receive any Liquid asset or amount.</p>
<custom-tabs category="lang">
<div slot="title">Rust</div>
<section>
<pre><code class="language-rust ignore">let addr = wollet.address(None)?;</code></pre>
</section>
<div slot="title">Python</div>
<section>
<pre><code class="language-python">addr = wollet.address(None)

</code></pre>
</section>
<div slot="title">Javascript</div>
<section>
<pre><code class="language-typescript">const addr = wollet.address(null).address().toString();
</code></pre>
</section>
</custom-tabs>
<h2 id="get-transactions-and-balance"><a class="header" href="#get-transactions-and-balance">Get Transactions and Balance</a></h2>
<p>It's possibile to get the list of wallet transactions with <code>Wollet::transactions()</code> and the balance <code>Wollet::balance()</code>.</p>
<p>Note: Liquid transactions are confidential, meaining that only sender and receiver can see their asset and amount. <code>Wollet</code> unblinds the transactions and returns unblinded data that can be shown to the user.</p>
<p><code>Wollet</code> however does not have internet access.
To fetch (new) wallet data, you need to use a "client" that fetches wallet transactions from some server.
In the next section we explain how (new) blockchain data can be obtained and added to the wallet.</p>
<custom-tabs category="lang">
<div slot="title">Rust</div>
<section>
<pre><code class="language-rust ignore">let txs = wollet.transactions()?;
let balance = wollet.balance()?;</code></pre>
</section>
<div slot="title">Python</div>
<section>
<pre><code class="language-python">txs = wollet.transactions()
balance = wollet.balance()
</code></pre>
</section>
<div slot="title">Javascript</div>
<section>
<pre><code class="language-typescript">const txs = wollet.transactions();
const balance = wollet.balance();
</code></pre>
</section>
</custom-tabs>
<hr />
<p>Next: <a href="scan.html">Update the Wallet</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="update-the-wallet"><a class="header" href="#update-the-wallet">Update the Wallet</a></h1>
<p>The fact that <code>Wollet</code> does have access to internet is a deliberate choice.
This allows <code>Wollet</code> to work offline, where they can generate addresses.</p>
<p>The connection is handled by a specific component, a Blockchain <strong>Client</strong>.
Blockchain clients connect to the specified server a fetch the wallet data from the blockchain.</p>
<p>LWK currently support 3 types of servers:</p>
<ul>
<li>Electrum Servers</li>
<li>Esplora Servers</li>
<li>Waterfalls Servers</li>
</ul>
<p>To delve into their differences and strength points see our <a href="clients.html">dedicated section</a>.</p>
<h2 id="create-a-client"><a class="header" href="#create-a-client">Create a Client</a></h2>
<p>In this guide we will use an <code>EsploraClient</code>.</p>
<p>You can create a new client with <code>EsploraClient::new()</code>, specifying the URL of the service.</p>
<h2 id="scan-the-blockchain"><a class="header" href="#scan-the-blockchain">Scan the Blockchain</a></h2>
<p>Given a <code>Wollet</code> you can call <code>EsploraClient::full_scan()</code>,
which performs a series of network calls that scan the blockchain to find transactions relevant for the wallet.</p>
<p><code>EsploraClient::full_scan()</code> has a stopping mechanisms that relies on BIP44 GAP LIMIT.
This might not fit every use cases.
In case you have large sequences of consecutive unused addresses you can use
<code>EsploraClient::full_scan_to_index()</code>.</p>
<h2 id="apply-the-update"><a class="header" href="#apply-the-update">Apply the Update</a></h2>
<p><code>EsploraClient::full_scan()</code> fetches, parses, (locally) unblind and serialized the fetched data in returned value, an <code>Update</code>.
The <code>Update</code> can be applied to the <code>Wollet</code> using <code>Wollet::apply_update()</code>.</p>
<p>After applying the update the wollet data will include the new transaction downloaded,
for instance more transactions can be returned and balance can increase (or decrease).</p>
<custom-tabs category="lang">
<div slot="title">Rust</div>
<section>
<pre><code class="language-rust ignore">use lwk_wollet::clients::blocking::EsploraClient;
// let url = "https://blockstream.info/liquidtestnet/api";
// let url = "https://blockstream.info/liquid/api";

let mut client = EsploraClient::new(&amp;url, network)?;

if let Some(update) = client.full_scan(&amp;wollet)? {
    wollet.apply_update(update)?;
}</code></pre>
</section>
<div slot="title">Python</div>
<section>
<pre><code class="language-python">url = "https://blockstream.info/liquidtestnet/api"
client = EsploraClient(url, network)

update = client.full_scan(wollet)
wollet.apply_update(update)
</code></pre>
</section>
<div slot="title">Javascript</div>
<section>
<pre><code class="language-typescript">const url = "https://waterfalls.liquidwebwallet.org/liquidtestnet/api";
const client = new lwk.EsploraClient(network, url, true, 4, false);

const update = await client.fullScan(wollet);
if (update) {
    wollet.applyUpdate(update);
}
</code></pre>
</section>
</custom-tabs>
<hr />
<p>Next: <a href="tx.html">Create a transaction</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="transaction-creation"><a class="header" href="#transaction-creation">Transaction Creation</a></h1>
<p>With a <code>Wollet</code> you can generate an address,
which can be used to receive some funds.
You can fetch the transactions receiving the funds using a "client",
and apply them to the wallet.
Now that the <code>Wollet</code> has a balance, it is able to craft transactions sending funds to desired destination.</p>
<p>The first step is construction a <code>TxBuilder</code> (or <code>WolletTxBuilder</code>), using <code>TxBuilder::new()</code> or <code>Wollet::tx_builder()</code>.
You can now specify how to build the transaction using the methods exposed by the <code>TxBuilder</code>.</p>
<h2 id="add-a-recipient"><a class="header" href="#add-a-recipient">Add a Recipient</a></h2>
<p>If you want to send some funds you need this information:</p>
<ul>
<li>Address: destination (confidential) address provided by the receiver</li>
<li>Amount: number of units of the asset (satoshi) to be sent.</li>
<li>Asset: identifier of the asset that should be sent</li>
</ul>
<p>Then you can call <code>TxBuilder::add_recipient()</code> to create an output which sends the amount of the asset, to the specified address.</p>
<p>You can add multiple recipients to the same transaction.</p>
<h2 id="advanced-options"><a class="header" href="#advanced-options">Advanced Options</a></h2>
<p>LWK allows to construct complex transactions, here there are few examples</p>
<ul>
<li>Set fee rate with <code>TxBuilder::fee_rate()</code></li>
<li><a href="manual.html">Manual coin selection</a></li>
<li><a href="external.html">External UTXOS</a></li>
<li><a href="explicit.html">Explicit inputs and outputs</a></li>
<li><a href="sendall.html">Send all LBTC</a></li>
<li><a href="issuance.html">Issuance</a>, <a href="reissuance.html">reissuance</a>, <a href="burn.html">burn</a></li>
</ul>
<h2 id="construct-the-transaction-pset"><a class="header" href="#construct-the-transaction-pset">Construct the Transaction (PSET)</a></h2>
<p>Once you set all the desired options to the <code>TxBuilder</code>.
You can construct the transaction calling <code>TxBuilder::finish()</code>.
This will return a Partially Signed Elements Transaction (<a href="https://github.com/ElementsProject/elements/blob/master/doc/pset.mediawiki">PSET</a>),
a transaction encoded in a format that facilitates sharing the transaction with signers.</p>
<custom-tabs category="lang">
<div slot="title">Rust</div>
<section>
<pre><code class="language-rust ignore">let mut pset = wollet
    .tx_builder()
    .add_recipient(&amp;address, sats, lbtc)?
    .finish()?;</code></pre>
</section>
<div slot="title">Python</div>
<section>
<pre><code class="language-python">b = network.tx_builder()
b.add_recipient(address, sats, lbtc)
pset = b.finish(wollet)
</code></pre>
</section>
<div slot="title">Javascript</div>
<section>
<pre><code class="language-typescript">const sats = BigInt(1000);
const address = new lwk.Address("&lt;address&gt;");
const asset = new lwk.AssetId("&lt;asset&gt;");

var builder = new lwk.TxBuilder(network)
builder = builder.addRecipient(address, sats, asset)
var pset = builder.finish(wollet)
</code></pre>
</section>
</custom-tabs>
<hr />
<p>Next: <a href="sign.html">Sign Transaction</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="transaction-signing"><a class="header" href="#transaction-signing">Transaction Signing</a></h1>
<p>Once you have created a PSET now you need to add some signatures to it.
This is done by the <code>Signer</code>,
however the signer might be isolated,
so we need some mechanisms to allow the signer to understand what is signing.</p>
<h2 id="get-the-pset-details"><a class="header" href="#get-the-pset-details">Get the PSET details</a></h2>
<p>This is done with <code>Wollet::get_details()</code>, which returns:</p>
<ul>
<li>missing signatures and the respective signers' fingerprints</li>
<li>net balance, the effect that transaction has on wallet (e.g. how much funds are sent out of the wallet)</li>
</ul>
<p>If the <code>Signer</code> fingeprint is included in the missing signatures,
then a <code>Signer</code> with that fingeprint expected to sign.</p>
<p>The balance can be shown to the user or validated against the <code>Signer</code> expectations.</p>
<p>It's worth noticing that <code>Wollet</code>s can work without internet,
so offline <code>Signer</code>s can have <code>Wollet</code>s instance to enhance the validation performed before signing.</p>
<custom-tabs category="lang">
<div slot="title">Rust</div>
<section>
<pre><code class="language-rust ignore">let details = wollet.get_details(&amp;pset)?;</code></pre>
</section>
<div slot="title">Python</div>
<section>
<pre><code class="language-python">details = wollet.pset_details(pset)
</code></pre>
</section>
<div slot="title">Javascript</div>
<section>
<pre><code class="language-typescript">const details = wollet.psetDetails(pset);
</code></pre>
</section>
</custom-tabs>
<h2 id="sign-the-pset"><a class="header" href="#sign-the-pset">Sign the PSET</a></h2>
<p>Once you have performed enough validation, you can call <code>Signer::sign</code>.
Which adds signatures from <code>Signer</code> to the PSET.</p>
<p>Once the PSET has enough signatures, you can broadcast to the Liquid Network.</p>
<custom-tabs category="lang">
<div slot="title">Rust</div>
<section>
<pre><code class="language-rust ignore">let sigs_added = signer.sign(&amp;mut pset)?;
assert_eq!(sigs_added, 1);</code></pre>
</section>
<div slot="title">Python</div>
<section>
<pre><code class="language-python">pset = signer.sign(pset)
</code></pre>
</section>
<div slot="title">Javascript</div>
<section>
<pre><code class="language-typescript">pset = signer.sign(pset)
</code></pre>
</section>
</custom-tabs>
<hr />
<p>Next: <a href="broadcast.html">Broadcast a Transaction</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="transaction-broadcast"><a class="header" href="#transaction-broadcast">Transaction Broadcast</a></h1>
<p>When a PSET has enough signatures, it's ready to be broadcasted to the Liquid Network.</p>
<h2 id="finalize-the-pset"><a class="header" href="#finalize-the-pset">Finalize the PSET</a></h2>
<p>First you need to call <code>Wollet::finalize()</code> to finalize the PSET and extract the signed transaction.</p>
<h2 id="broadcast-the-transaction"><a class="header" href="#broadcast-the-transaction">Broadcast the Transaction</a></h2>
<p>The transaction returned by the previous step can be sent to the Liquid Network with <code>EsploraClient::broadcast()</code>.</p>
<h2 id="apply-the-transaction"><a class="header" href="#apply-the-transaction">Apply the Transaction</a></h2>
<p>If you send a transaction you might want to see the balance decrease immediately.
With LWK this does not happens automatically,
you can do a "full scan" and apply the returned update.
However this requires network calls and it might be slow,
if you want your balance to be updated immediately,
you can call <code>Wollet::apply_tx()</code>.</p>
<custom-tabs category="lang">
<div slot="title">Rust</div>
<section>
<pre><code class="language-rust ignore">let tx = wollet.finalize(&amp;mut pset)?;
let txid = client.broadcast(&amp;tx)?;

// (optional)
wollet.apply_transaction(tx)?;</code></pre>
</section>
<div slot="title">Python</div>
<section>
<pre><code class="language-python">pset = wollet.finalize(pset)
const tx = pset.extractTx();
const txid = await client.broadcastTx(tx)

// (optional)
wollet.applyTransaction(tx);
</code></pre>
</section>
<div slot="title">Javascript</div>
<section>
<pre><code class="language-typescript">pset = wollet.finalize(pset)
const tx = pset.extractTx();
const txid = await client.broadcastTx(tx)

// (optional)
wollet.applyTransaction(tx);
</code></pre>
</section>
</custom-tabs>
<hr />
<p>Next: <a href="advanced.html">Advanced Features</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="blockchain-clients"><a class="header" href="#blockchain-clients">Blockchain Clients</a></h1>
<p>LWK supports different ways to retrieve wallet data from the Liquid blockchain:</p>
<ul>
<li><strong>Electrum</strong> - TCP-based protocol, widely supported</li>
<li><strong>Esplora</strong> - HTTP-based REST API, browser-compatible</li>
<li><strong>Waterfalls</strong> - Optimized HTTP-based protocol with reduced roundtrips</li>
</ul>
<p>Some clients also come in different flavors: blocking or async.
It's also possible to connect to authenticated backends for enterprise deployments.</p>
<h2 id="quick-comparison"><a class="header" href="#quick-comparison">Quick Comparison</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Feature</th><th>Electrum</th><th>Esplora</th><th>Waterfalls</th></tr></thead><tbody>
<tr><td><strong>Protocol</strong></td><td>TCP</td><td>HTTP/HTTPS</td><td>HTTP/HTTPS</td></tr>
<tr><td><strong>Browser Support</strong></td><td>‚ùå No</td><td>‚úÖ Yes</td><td>‚úÖ Yes</td></tr>
<tr><td><strong>Mobile Support</strong></td><td>‚úÖ Yes</td><td>‚úÖ Yes</td><td>‚úÖ Yes</td></tr>
<tr><td><strong>Sync Speed</strong></td><td>üèÉ Average</td><td>üê¢ Slower</td><td>üöÄ Fastest</td></tr>
<tr><td><strong>Roundtrips</strong></td><td>Many but batched</td><td>Many</td><td>Few</td></tr>
<tr><td><strong>Async Support</strong></td><td>‚ùå No</td><td>‚úÖ Yes</td><td>‚úÖ Yes</td></tr>
<tr><td><strong>Authentication</strong></td><td>‚ùå No</td><td>‚úÖ OAuth2</td><td>‚úÖ OAuth2</td></tr>
<tr><td><strong>Maturity</strong></td><td>‚≠ê‚≠ê‚≠ê Mature</td><td>‚≠ê‚≠ê‚≠ê Mature</td><td>‚≠ê‚≠ê New</td></tr>
</tbody></table>
</div>
<h2 id="electrum"><a class="header" href="#electrum">Electrum</a></h2>
<p>The Electrum protocol is the most widely used light-client syncing mechanism for Bitcoin and Liquid wallets.</p>
<p><strong>Key characteristics:</strong></p>
<ul>
<li><strong>Protocol:</strong> TCP-based</li>
<li><strong>Performance:</strong> Good</li>
<li><strong>Availability:</strong> Only blocking variant</li>
<li><strong>Platform support:</strong> Desktop, mobile, and server applications</li>
<li><strong>Browser support:</strong> ‚ùå No (TCP not available in browsers)</li>
<li><strong>Default servers:</strong> Blockstream public Electrum servers</li>
</ul>
<p>This client is recommended for desktop, mobile, and server applications where interoperability is critical. By default, Blockstream public Electrum servers are used, but you can also specify custom URLs for private or local deployments.</p>
<custom-tabs category="lang">
<div slot="title">Rust</div>
<section>
<pre><code class="language-rust ignore">use lwk_wollet::{ElectrumClient, ElectrumUrl};

let electrum_url = ElectrumUrl::new("blockstream.info:995", true, true)?;
let mut client = ElectrumClient::new(&amp;electrum_url)?;</code></pre>
</section>
<div slot="title">Python</div>
<section>
<pre><code class="language-python"># Create electrum client with custom URL
client = ElectrumClient("blockstream.info:995", tls=True, validate_domain=True)

# Or use the default electrum client for the network
default_client = Network.mainnet().default_electrum_client()
</code></pre>
</section>
</custom-tabs>
<h2 id="esplora"><a class="header" href="#esplora">Esplora</a></h2>
<p>The Esplora client is based on the <a href="https://github.com/Blockstream/esplora/blob/master/API.md">Esplora API</a>, a popular HTTP-based blockchain explorer API.</p>
<p><strong>Key characteristics:</strong></p>
<ul>
<li><strong>Protocol:</strong> HTTP/HTTPS REST API</li>
<li><strong>Performance:</strong> Multiple roundtrips required for wallet sync</li>
<li><strong>Availability:</strong> Both blocking and async variants</li>
<li><strong>Browser support:</strong> ‚úÖ Yes, works in web browsers</li>
<li><strong>Authentication:</strong> Supports OAuth2 for enterprise deployments</li>
</ul>
<p>This client is ideal for web applications and scenarios where HTTP-based communication is required. While it requires more roundtrips than Electrum, it's the only option for browser-based applications and offers broad compatibility.</p>
<custom-tabs category="lang">
<div slot="title">Rust</div>
<section>
<pre><code class="language-rust ignore">use lwk_wollet::clients::blocking::EsploraClient;

let esplora_url = "https://blockstream.info/liquid/api";
let mut client = EsploraClient::new(esplora_url, ElementsNetwork::Liquid)?;</code></pre>
</section>
<div slot="title">Python</div>
<section>
<pre><code class="language-python">url = "https://blockstream.info/liquid/api"
client = EsploraClient(url, Network.mainnet())
</code></pre>
</section>
<div slot="title">Javascript</div>
<section>
<pre><code class="language-typescript">const url_esplora = "https://blockstream.info/liquid/api";
const esplora_client = new lwk.EsploraClient(lwk.Network.liquid(), url_esplora, true, 4, false);
</code></pre>
</section>
</custom-tabs>
<h3 id="authenticated-esplora"><a class="header" href="#authenticated-esplora">Authenticated Esplora</a></h3>
<p>Some Esplora servers, particularly enterprise deployments like <a href="https://blockstream.info/explorer-api">Blockstream Enterprise</a>, require authentication for access. LWK supports OAuth2-based authentication with automatic token refresh.</p>
<p>Use authenticated clients when:</p>
<ul>
<li>Connecting to private or enterprise Esplora instances</li>
<li>Requiring guaranteed rate limits and service quality</li>
<li>Needing additional privacy and dedicated infrastructure</li>
</ul>
<custom-tabs category="lang">
<div slot="title">Rust</div>
<section>
<pre><code class="language-rust ignore">use lwk_wollet::clients::asyncr::{EsploraClient as AsyncEsploraClient, EsploraClientBuilder};
use lwk_wollet::clients::TokenProvider;

let base_url = "https://enterprise.blockstream.info/liquid/api";
let client_id = "your_client_id";
let client_secret = "your_client_secret";
let login_url =
    "https://login.blockstream.com/realms/blockstream-public/protocol/openid-connect/token";

let mut client = EsploraClientBuilder::new(base_url, ElementsNetwork::Liquid)
    .token_provider(TokenProvider::Blockstream {
        url: login_url.to_string(),
        client_id: client_id.to_string(),
        client_secret: client_secret.to_string(),
    })
    .build()?;</code></pre>
</section>
</custom-tabs>
<h2 id="waterfalls"><a class="header" href="#waterfalls">Waterfalls</a></h2>
<p><a href="https://github.com/RCasatta/waterfalls">Waterfalls</a> is an optimized blockchain indexer designed to significantly reduce the number of roundtrips required for wallet synchronization compared to traditional Esplora.</p>
<p><strong>Key characteristics:</strong></p>
<ul>
<li><strong>Protocol:</strong> HTTP/HTTPS REST API (Esplora-compatible with extensions)</li>
<li><strong>Performance:</strong> Fewer roundtrips than standard Esplora, faster sync times</li>
<li><strong>Availability:</strong> Both blocking and async variants</li>
<li><strong>Browser support:</strong> ‚úÖ Yes, works in web browsers</li>
<li><strong>Maturity:</strong> Newer technology, still evolving</li>
</ul>
<p><strong>Important:</strong> The public Waterfalls instance shown in the examples (<code>waterfalls.liquidwebwallet.org</code>) is provided for testing and development only.</p>
<custom-tabs category="lang">
<div slot="title">Rust</div>
<section>
<pre><code class="language-rust ignore">let waterfalls_url = "https://waterfalls.liquidwebwallet.org/liquid/api";
let mut client = EsploraClientBuilder::new(waterfalls_url, ElementsNetwork::Liquid)
    .waterfalls(true)
    .build()?;</code></pre>
</section>
<div slot="title">Python</div>
<section>
<pre><code class="language-python">url = "https://waterfalls.liquidwebwallet.org/liquid/api"
client = EsploraClient.new_waterfalls(url, Network.mainnet())
</code></pre>
</section>
<div slot="title">Javascript</div>
<section>
<pre><code class="language-typescript">const url_waterfalls = "https://waterfalls.liquidwebwallet.org/liquid/api";
const waterfalls_client = new lwk.EsploraClient(lwk.Network.liquid(), url_waterfalls, true, 4, false);
</code></pre>
</section>
</custom-tabs>
<h3 id="authenticated-waterfalls"><a class="header" href="#authenticated-waterfalls">Authenticated Waterfalls</a></h3>
<p>Waterfalls clients also support OAuth2-based authentication for enterprise deployments, similar to the <a href="https://blockstream.info/explorer-api">Blockstream Enterprise</a> authenticated Esplora clients.</p>
<custom-tabs category="lang">
<div slot="title">Rust</div>
<section>
<pre><code class="language-rust ignore">let base_url = "https://enterprise.blockstream.info/liquid/api/waterfalls"; // &lt;- changed
let client_id = "your_client_id";
let client_secret = "your_client_secret";
let login_url =
    "https://login.blockstream.com/realms/blockstream-public/protocol/openid-connect/token";

let mut client = EsploraClientBuilder::new(base_url, ElementsNetwork::Liquid)
    .waterfalls(true) // &lt;- added
    .token_provider(TokenProvider::Blockstream {
        url: login_url.to_string(),
        client_id: client_id.to_string(),
        client_secret: client_secret.to_string(),
    })
    .build()?;</code></pre>
</section>
</custom-tabs>
<div style="break-before: page; page-break-before: always;"></div><h1 id="liquid-multisig"><a class="header" href="#liquid-multisig">Liquid Multisig</a></h1>
<p>Liquid has a very similar scripting model with respect to Bitcoin.
It allows to create complex spending conditions for your wallets.</p>
<p>A relatively simple, yet powerful, example is <strong>multisig</strong>.
In a multisig wallet you need <em>n</em> signatures from a set of <em>m</em> public keys to spend a wallet UTXO.</p>
<p>In this guide we will explain how to setup and operate a Liquid Multisig wallet.</p>
<h2 id="setup"><a class="header" href="#setup">Setup</a></h2>
<p>We want to create a <em>2of3</em> between Alice, Bob and Carol.</p>
<p>First each multisig participant creates their signer.
Then they get their <em>xpub</em>, and share it with the coordinator, in this case Carol.
Carol uses the xpubs to construct the multisig CT descriptor.
Finally Carol shares the multisig CT descriptor with Alice and Bob.</p>
<pre class="mermaid">sequenceDiagram
    participant A as Alice
    participant B as Bob
    participant C as Carol&lt;br&gt;(coordinator)
    Note over A: signer A üîë
    Note over B: signer B üîë
    Note over C: signer C üîë
    A-&gt;&gt;C: xpub A
    B-&gt;&gt;C: xpub B
    C-&gt;&gt;C: xpub C
    Note over C: Create&lt;br&gt;CT descriptorüëÄ
    C-&gt;&gt;B: CT descriptorüëÄ
    C-&gt;&gt;A: CT descriptorüëÄ
</pre>
<div class="warning">
‚ö†Ô∏è It's important that all participants in a multisig know the CT descriptors, as it is necessary to validate if addresses and (U)TXO belong to the wallet.
</div>
<custom-tabs category="lang">
<div slot="title">Rust</div>
<section>
<pre><code class="language-rust ignore">let is_mainnet = false;
// Derivation for multisig
let bip = lwk_common::Bip::Bip87;

// Alice creates their signer and gets the xpub
let mnemonic_a = Mnemonic::generate(12)?;
let signer_a = SwSigner::new(&amp;mnemonic_a.to_string(), is_mainnet)?;
let xpub_a = signer_a.keyorigin_xpub(bip, is_mainnet)?;

// Bob creates their signer and gets the xpub
let mnemonic_b = Mnemonic::generate(12)?;
let signer_b = SwSigner::new(&amp;mnemonic_b.to_string(), is_mainnet)?;
let xpub_b = signer_b.keyorigin_xpub(bip, is_mainnet)?;

// Carol, who acts as a coordinator, creates their signer and gets the xpub
let mnemonic_c = Mnemonic::generate(12)?;
let signer_c = SwSigner::new(&amp;mnemonic_c.to_string(), is_mainnet)?;
let xpub_c = signer_c.keyorigin_xpub(bip, is_mainnet)?;

// Carol generates a random SLIP77 descriptor blinding key
let mut slip77_rand_key = [0u8; 32];
use rand::{thread_rng, Rng};
thread_rng().fill(&amp;mut slip77_rand_key);
let slip77_rand_key = slip77_rand_key.to_hex();
let desc_blinding_key = format!("slip77({slip77_rand_key})");

// Carol uses the collected xpubs and the descriptor blinding key to create
// the 2of3 descriptor
let threshold = 2;
let desc = format!("ct({desc_blinding_key},elwsh(multi({threshold},{xpub_a}/&lt;0;1&gt;/*,{xpub_b}/&lt;0;1&gt;/*,{xpub_c}/&lt;0;1&gt;/*)))");
// Validate the descriptor string
let wd = WolletDescriptor::from_str(&amp;desc)?;</code></pre>
</section>
<div slot="title">Python</div>
<section>
<pre><code class="language-python">network = Network.testnet()
# Derivation for multisig
bip = Bip.new_bip87()

# Alice creates their signer and gets the xpub
signer_a = Signer.random(network)
xpub_a = signer_a.keyorigin_xpub(bip);

# Bob creates their signer and gets the xpub
signer_b = Signer.random(network)
xpub_b = signer_b.keyorigin_xpub(bip);

# Carol, who acts as a coordinator, creates their signer and gets the xpub
signer_c = Signer.random(network)
xpub_c = signer_c.keyorigin_xpub(bip);

# Carol generates a random SLIP77 descriptor blinding key
import os
slip77_rand_key = os.urandom(32).hex()
desc_blinding_key = f"slip77({slip77_rand_key})"

# Carol uses the collected xpubs and the descriptor blinding key to create
# the 2of3 descriptor
threshold = 2;
desc = f"ct({desc_blinding_key},elwsh(multi({threshold},{xpub_a}/&lt;0;1&gt;/*,{xpub_b}/&lt;0;1&gt;/*,{xpub_c}/&lt;0;1&gt;/*)))"
# Validate the descriptor string
wd = WolletDescriptor(desc)
</code></pre>
</section>
<div slot="title">Javascript</div>
<section>
<pre><code class="language-typescript">const network = lwk.Network.testnet();
// Derivation for multisig
const bip = lwk.Bip.bip87();

// Alice creates their signer and gets the xpub
const mnemonic_a = lwk.Mnemonic.fromRandom(12);
const signer_a = new lwk.Signer(mnemonic_a, network);
const xpub_a = signer_a.keyoriginXpub(bip);

// Bob creates their signer and gets the xpub
const mnemonic_b = lwk.Mnemonic.fromRandom(12);
const signer_b = new lwk.Signer(mnemonic_b, network);
const xpub_b = signer_b.keyoriginXpub(bip);

// Carol, who acts as a coordinator, creates their signer and gets the xpub
const mnemonic_c = lwk.Mnemonic.fromRandom(12);
const signer_c = new lwk.Signer(mnemonic_c, network);
const xpub_c = signer_c.keyoriginXpub(bip);

// Carol generates a random SLIP77 descriptor blinding key
const slip77_rand_key = "&lt;random-64-hex-chars&gt;";
const desc_blinding_key = `slip77(${slip77_rand_key})`;

// Carol uses the collected xpubs and the descriptor blinding key to create
// the 2of3 descriptor
const threshold = 2;
const desc = `ct(${desc_blinding_key},elwsh(multi(${threshold},${xpub_a}/&lt;0;1&gt;/*,${xpub_b}/&lt;0;1&gt;/*,${xpub_c}/&lt;0;1&gt;/*)))`;
// Validate the descriptor string
const wd = new lwk.WolletDescriptor(desc);
</code></pre>
</section>
</custom-tabs>
<p>In this example Carol creates the SLIP77 key at random, however this is not mandatory and valid alternatives are:</p>
<ul>
<li>"elip151", to deterministically derive the descriptor blinding key from the "bitcoin" descriptor;</li>
<li>derive a SLIP77 deterministic key from a signer, however this descriptor blinding key might be re used in other descriptors.</li>
</ul>
<h2 id="receive-and-monitor"><a class="header" href="#receive-and-monitor">Receive and monitor</a></h2>
<p>The Liquid Multisig wallet is identified by the CT descriptor created during setup.
The descriptor encodes all the information needed to derive scriptpubkeys and blinding keys which are necessary to operate the wallet. In general, it also contains the xpubs <em>key origin</em>, information needed to by signers to sign, consisting in the signer fingerprint and derivation paths.</p>
<p>With the wallet CT descriptor you can:</p>
<ul>
<li>Generate wallet (confidential) addresses</li>
<li>Get the (unblinded) list of the wallet transactions</li>
<li>Get the wallet balance</li>
</ul>
<custom-tabs category="lang">
<div slot="title">Rust</div>
<section>
<pre><code class="language-rust ignore">// Carol creates the wollet
let network = ElementsNetwork::LiquidTestnet;
let mut wollet_c = Wollet::without_persist(network, wd)?;

// With the wollet, Carol can obtain addresses, transactions and balance
let addr = wollet_c.address(None)?;
let txs = wollet_c.transactions()?;
let balance = wollet_c.balance()?;

// Update the wollet state
let url = "https://blockstream.info/liquidtestnet/api";
let mut client = EsploraClient::new(&amp;url, network)?;

if let Some(update) = client.full_scan(&amp;wollet_c)? {
    wollet_c.apply_update(update)?;
}</code></pre>
</section>
<div slot="title">Python</div>
<section>
<pre><code class="language-python"># Carol creates the wollet
wollet_c = Wollet(network, wd, datadir=None)

# With the wollet, Carol can obtain addresses, transactions and balance
addr = wollet_c.address(None);
txs = wollet_c.transactions();
balance = wollet_c.balance();

# Update the wollet state
url = "https://blockstream.info/liquidtestnet/api"
client = EsploraClient(url, network)

update = client.full_scan(wollet_c)
wollet_c.apply_update(update)
</code></pre>
</section>
<div slot="title">Javascript</div>
<section>
<pre><code class="language-typescript">// Carol creates the wollet
const wollet_c = new lwk.Wollet(network, wd);

// With the wollet, Carol can obtain addresses, transactions and balance
const addr = wollet_c.address(null).address().toString();
const txs = wollet_c.transactions();
const balance = wollet_c.balance();

// Update the wollet state
const url = "https://waterfalls.liquidwebwallet.org/liquidtestnet/api";
const client = new lwk.EsploraClient(network, url, true, 4, false);

const update = await client.fullScan(wollet_c);
if (update) {
    wollet_c.applyUpdate(update);
}
</code></pre>
</section>
</custom-tabs>
<p>Note that for generating addresses, getting transactions and balance, you have the same procedure for both singlesig and multisig wallets.</p>
<h2 id="send"><a class="header" href="#send">Send</a></h2>
<p>As for addresses, transactions and balance, to create a multisig transaction you only need the CT descriptor.
In this example Carol creates the transaction.
Since she created the transaction, she's comfortable in skipping validation and she also signs it.
However the wallet is a 2of3, so it needs either Alice or Bob to fully sign the transaction.
Carol sends the transaction (in PSET format) to Bob.
Bob examines the PSET and checks that it does what it's supposed to do (e.g. outgoing addresses, assets, amounts and fees), then it signs the PSET and sends it back to Carol.
The PSET is now fully signed, Carol can finalize it and broadcast the transaction.</p>
<pre class="mermaid">sequenceDiagram
    participant A as Alice
    participant B as Bob
    participant C as Carol&lt;br&gt;(coordinator)
    Note over C: Create PSET&lt;br&gt;(using CT descriptorüëÄ)
    Note over C: signer C üîë signs PSET
    C-&gt;&gt;B: PSET
    Note over B: Analyze PSET&lt;br&gt;(using CT descriptorüëÄ)
    Note over B: signer B üîë signs PSET
    B-&gt;&gt;C: PSET
    Note over C: Finalize PSET and&lt;br&gt;extract TX
    Note over C: Broadcast TX
</pre>
<custom-tabs category="lang">
<div slot="title">Rust</div>
<section>
<pre><code class="language-rust ignore">// Carol creates a transaction send few sats to a certain address
let address = "&lt;address&gt;";
let sats = 1000;
let lbtc = network.policy_asset();

let mut pset = wollet_c
    .tx_builder()
    .add_recipient(&amp;address, sats, lbtc)?
    .finish()?;

// Carol signs the transaction
let sigs_added = signer_c.sign(&amp;mut pset)?;
assert_eq!(sigs_added, 1);

// Carol sends the PSET to Bob
// Bob wants to analyze the PSET before signing, thus he creates a wollet
let wd = WolletDescriptor::from_str(&amp;desc)?;
let mut wollet_b = Wollet::without_persist(network, wd)?;
if let Some(update) = client.full_scan(&amp;wollet_b)? {
    wollet_b.apply_update(update)?;
}
// Then Bob uses the wollet to analyze the PSET
let details = wollet_b.get_details(&amp;pset)?;
// PSET has a reasonable fee
assert!(details.balance.fee &lt; 100);
// PSET has a signature from Carol
let fingerprints_has = details.fingerprints_has();
assert_eq!(fingerprints_has.len(), 1);
assert!(fingerprints_has.contains(&amp;signer_c.fingerprint()));
// PSET needs a signature from either Bob or Carol
let fingerprints_missing = details.fingerprints_missing();
assert_eq!(fingerprints_missing.len(), 2);
assert!(fingerprints_missing.contains(&amp;signer_a.fingerprint()));
assert!(fingerprints_missing.contains(&amp;signer_b.fingerprint()));
// PSET has a single recipient, with data matching what was specified above
assert_eq!(details.balance.recipients.len(), 1);
let recipient = details.balance.recipients[0].clone();
assert_eq!(recipient.address.unwrap(), address);
assert_eq!(recipient.asset.unwrap(), lbtc);
assert_eq!(recipient.value.unwrap(), sats);

// Bob is satisified with the PSET and signs it
let sigs_added = signer_b.sign(&amp;mut pset)?;
assert_eq!(sigs_added, 1);

// Bob sends the PSET back to Carol
// Carol checks that the PSET has enough signatures
let details = wollet_c.get_details(&amp;pset)?;
assert_eq!(details.fingerprints_has().len(), 2);

// Carol finalizes the PSET and broadcast the transaction
let tx = wollet_c.finalize(&amp;mut pset)?;
let txid = client.broadcast(&amp;tx)?;</code></pre>
</section>
<div slot="title">Python</div>
<section>
<pre><code class="language-python"># Carol creates a transaction send few sats to a certain address
address = "&lt;address&gt;"
sats = 1000
lbtc = network.policy_asset()

b = network.tx_builder()
b.add_recipient(address, sats, lbtc)
pset = b.finish(wollet_c)

pset = signer_c.sign(pset)

# Carol sends the PSET to Bob
# Bob wants to analyze the PSET before signing, thus he creates a wollet
wd = WolletDescriptor(desc)
wollet_b = Wollet(network, wd, datadir=None)
update = client.full_scan(wollet_b)
wollet_b.apply_update(update)
# Then Bob uses the wollet to analyze the PSET
details = wollet_b.pset_details(pset)
# PSET has a reasonable fee
assert details.balance().fee() &lt; 100
# PSET has a signature from Carol
fingerprints_has = details.fingerprints_has()
assert len(fingerprints_has) == 1
assert signer_c.fingerprint() in fingerprints_has
# PSET needs a signature from either Bob or Carol
fingerprints_missing = details.fingerprints_missing()
assert len(fingerprints_missing) == 2
assert signer_a.fingerprint() in fingerprints_missing
assert signer_b.fingerprint() in fingerprints_missing
# PSET has a single recipient, with data matching what was specified above
assert len(details.balance().recipients()) == 1
recipient = details.balance().recipients()[0]
assert str(recipient.address()) == str(address)
assert recipient.asset() == lbtc
assert recipient.value() == sats

# Bob is satisified with the PSET and signs it
pset = signer_b.sign(pset)

# Bob sends the PSET back to Carol
# Carol checks that the PSET has enough signatures
details = wollet_c.pset_details(pset)
fingerprints_has = details.fingerprints_has()
assert len(fingerprints_has) == 2

# Carol finalizes the PSET and broadcast the transaction
tx = pset.finalize()
txid = client.broadcast(tx)
</code></pre>
</section>
<div slot="title">Javascript</div>
<section>
<pre><code class="language-typescript">// Carol creates a transaction send few sats to a certain address
const sats = BigInt(1000);
const address = new lwk.Address("&lt;address&gt;");
const asset = new lwk.AssetId("&lt;asset&gt;");

var builder = new lwk.TxBuilder(network)
builder = builder.addRecipient(address, sats, asset)
var pset = builder.finish(wollet_c)

pset = signer_c.sign(pset)

// Carol sends the PSET to Bob
// Bob wants to analyze the PSET before signing, thus he creates a wollet
const wd_b = new lwk.WolletDescriptor(desc);
const wollet_b = new lwk.Wollet(network, wd_b);
const update_b = await client.fullScan(wollet_b);
if (update_b) {
    wollet_b.applyUpdate(update_b);
}
// Then Bob uses the wollet to analyze the PSET
const details = wollet_b.psetDetails(pset);
// PSET has a reasonable fee
console.assert(details.balance().fee() &lt; 100);
// PSET has a signature from Carol
console.assert(details.fingerprintsHas().length === 1);
console.assert(details.fingerprintsHas().includes(signer_c.fingerprint()));
// PSET needs a signature from either Bob or Carol
console.assert(details.fingerprintsMissing().length === 2);
console.assert(details.fingerprintsMissing().includes(signer_a.fingerprint()));
console.assert(details.fingerprintsMissing().includes(signer_b.fingerprint()));
// PSET has a single recipient, with data matching what was specified above
console.assert(details.balance().recipients().length === 1);
const recipient = details.balance().recipients()[0];
console.assert(recipient.address().toString() === address.toString());
console.assert(recipient.asset().toString() === asset.toString());
console.assert(recipient.value() === sats);

// Bob is satisified with the PSET and signs it
pset = signer_b.sign(pset)

// Bob sends the PSET back to Carol
// Carol checks that the PSET has enough signatures
const details_b = wollet_b.psetDetails(pset);
console.assert(details_b.fingerprintsHas().length === 2);

// Carol finalizes the PSET and broadcast the transaction
pset = wollet_c.finalize(pset)
const tx = pset.extractTx();
const txid = await client.broadcastTx(tx);
</code></pre>
</section>
</custom-tabs>
<div class="warning">
‚ö†Ô∏è Bob needs the CT descriptor to obtain the PSET details, in particular the net balance with respect to the wallet, i.e. how much is being sent out of the wallet.
</div>
<p>In this example we went through an example where the coordinator is one of the multisig participants and the PSET is signed serially. In general, this is not the case.
The coordinator can be a utility service, as long as it knows the multisig CT descriptor.
Also the PSET can be signed in parallel, and in this case the coordinator must combine the signed PSET using <code>Wollet::combine()</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="issuance"><a class="header" href="#issuance">Issuance</a></h1>
<p>Asset issuance on Liquid allows you to create new digital assets. When you issue an asset, you create a certain amount of that asset and optionally you also create another asset, called reissuance token, that allows you to create more of the asset later.</p>
<h2 id="understanding-asset-issuance"><a class="header" href="#understanding-asset-issuance">Understanding Asset Issuance</a></h2>
<p>When issuing an asset, you need to specify:</p>
<ul>
<li><strong>Asset amount</strong>: The number of units (in satoshis) of the asset to create</li>
<li><strong>Asset receiver</strong>: The address that will receive the newly issued asset (optional, defaults to a wallet address)</li>
<li><strong>Token amount</strong>: The number of reissuance tokens to create (optional, can be 0)</li>
<li><strong>Token receiver</strong>: The address that will receive the reissuance tokens (optional, defaults to a wallet address)</li>
<li><strong>Contract</strong>: Metadata about the asset (optional, necessary for asset registry)</li>
</ul>
<p>The asset receiver address and token receiver address can belong to different wallets with different spending policies, allowing for a more secure and customizable setup according to the issuer's needs.</p>
<p>The asset ID is deterministically derived from the transaction input and contract metadata (if provided). This means that if you use the same contract and transaction input, you'll get the same asset ID.</p>
<h2 id="creating-a-contract"><a class="header" href="#creating-a-contract">Creating a Contract</a></h2>
<p>A contract defines metadata about your asset, such as its name, ticker, precision, and issuer information. While contracts are optional, they are highly recommended as they allow your asset to be registered in the Liquid Asset Registry and displayed with proper metadata in wallets.</p>
<p>A contract contains:</p>
<ul>
<li><strong>domain</strong>: The domain of the asset issuer (e.g., "example.com")</li>
<li><strong>issuer_pubkey</strong>: The public key of the issuer (33 bytes, hex-encoded)</li>
<li><strong>name</strong>: The name of the asset (1-255 ASCII characters)</li>
<li><strong>precision</strong>: Decimal precision (0-8, where 8 is like Bitcoin)</li>
<li><strong>ticker</strong>: The ticker symbol (3-24 characters, letters, numbers, dots, and hyphens)</li>
<li><strong>version</strong>: Contract version (currently only 0 is supported)</li>
</ul>
<p>Amounts expressed in satoshi are always whole numbers without any decimal places. If you want to represent decimal values, you should use the "precision" variable in the contract. This variable determines the number of decimal places, i.e., how many digits appear after the decimal point. The following table shows different precision values with the issuance of 1 million satoshi.</p>
<div class="table-wrapper"><table><thead><tr><th>Satoshi</th><th>Precision</th><th>Asset units</th></tr></thead><tbody>
<tr><td>1.000.000</td><td>0</td><td>1.000.000</td></tr>
<tr><td>1.000.000</td><td>1</td><td>100.000,0</td></tr>
<tr><td>1.000.000</td><td>2</td><td>10.000,00</td></tr>
<tr><td>1.000.000</td><td>3</td><td>1.000,000</td></tr>
<tr><td>1.000.000</td><td>4</td><td>100,000</td></tr>
<tr><td>1.000.000</td><td>5</td><td>10,00000</td></tr>
<tr><td>1.000.000</td><td>6</td><td>1,000000</td></tr>
<tr><td>1.000.000</td><td>8</td><td>0.1000000</td></tr>
<tr><td>1.000.000</td><td>8</td><td>0.01000000</td></tr>
</tbody></table>
</div><custom-tabs category="lang">
<div slot="title">Rust</div>
<section>
<pre><code class="language-rust ignore">let contract_str = "{\"entity\":{\"domain\":\"ciao.it\"},\"issuer_pubkey\":\"0337cceec0beea0232ebe14cba0197a9fbd45fcf2ec946749de920e71434c2b904\",\"name\":\"name\",\"precision\":8,\"ticker\":\"TTT\",\"version\":0}";
let contract = Contract::from_str(contract_str)?;</code></pre>
</section>
<div slot="title">Python</div>
<section>
<pre><code class="language-python">contract = Contract(
    domain = "ciao.it", \
    issuer_pubkey = "0337cceec0beea0232ebe14cba0197a9fbd45fcf2ec946749de920e71434c2b904", \
    name = "name", \
    precision = 8, 
    ticker = "TTT", 
    version = 0)
</code></pre>
</section>
</custom-tabs>
<h2 id="issuing-an-asset"><a class="header" href="#issuing-an-asset">Issuing an Asset</a></h2>
<p>To issue an asset, use <code>TxBuilder::issue_asset()</code> before calling <code>finish()</code>. You need to have some LBTC in your wallet to pay for the transaction fees.</p>
<custom-tabs category="lang">
<div slot="title">Rust</div>
<section>
<pre><code class="language-rust ignore">// Issue asset
let issued_asset = 10_000;
let reissuance_tokens = 1;

// Create a transaction builder and the issuance transaction
let builder = wollet.tx_builder();
//  isue asset
let mut pset = builder
    .issue_asset(
        issued_asset,
        None, // None -&gt; a wallet from the address is used
        reissuance_tokens,
        None, // None -&gt; a wallet from the address is used
        Some(contract.clone()),
    )?
    .finish()?;

// Sign the transaction and finalize it
let signatures_added = signer.sign(&amp;mut pset).expect("signing failed");
let _ = wollet.finalize(&amp;mut pset)?;
let tx = pset.extract_tx()?;

// Broadcast the transaction
let txid = client.broadcast(&amp;tx)?;</code></pre>
</section>
<div slot="title">Python</div>
<section>
<pre><code class="language-python">issued_asset = 10000
reissuance_tokens = 1

# Create an issuance transaction 
builder = network.tx_builder()
builder.issue_asset(issued_asset, wollet_adddress, reissuance_tokens, wollet_adddress, contract)
unsigned_pset = builder.finish(wollet)
</code></pre>
</section>
</custom-tabs>
<h2 id="getting-asset-and-token-ids"><a class="header" href="#getting-asset-and-token-ids">Getting Asset and Token IDs</a></h2>
<p>After creating the issuance PSET, you can extract the asset ID and reissuance token ID from the transaction input:</p>
<custom-tabs category="lang">
<div slot="title">Rust</div>
<section>
<pre><code class="language-rust ignore">let asset_id = pset.inputs()[0].issuance_ids().0;
let token_id = pset.inputs()[0].issuance_ids().1;</code></pre>
</section>
<div slot="title">Python</div>
<section>
<pre><code class="language-python">asset_id = signed_pset.inputs()[0].issuance_asset()
token_id = signed_pset.inputs()[0].issuance_token()
</code></pre>
</section>
</custom-tabs>
<h2 id="complete-example"><a class="header" href="#complete-example">Complete Example</a></h2>
<p>Here's a complete example that issues an asset, signs it, and broadcasts it:</p>
<custom-tabs category="lang">
<div slot="title">Rust</div>
<section>
<pre><code class="language-rust ignore">
let mut client = test_client_electrum(&amp;env.electrum_url());

// Create wallet
let mnemonic = "abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon about";

let signer = SwSigner::new(mnemonic, false)?;
let desc = signer.wpkh_slip77_descriptor()?;

let mut wollet = Wollet::without_persist(network, WolletDescriptor::from_str(&amp;desc)?)?;
let wollet_address = wollet.address(None)?;
let wallet_address_str = wollet_address.address().to_string();

let txid =

let contract_str = "{\"entity\":{\"domain\":\"ciao.it\"},\"issuer_pubkey\":\"0337cceec0beea0232ebe14cba0197a9fbd45fcf2ec946749de920e71434c2b904\",\"name\":\"name\",\"precision\":8,\"ticker\":\"TTT\",\"version\":0}";
let contract = Contract::from_str(contract_str)?;

// Issue asset
let issued_asset = 10_000;
let reissuance_tokens = 1;

// Create a transaction builder and the issuance transaction
let builder = wollet.tx_builder();
//  isue asset
let mut pset = builder
    .issue_asset(
        issued_asset,
        None, // None -&gt; a wallet from the address is used
        reissuance_tokens,
        None, // None -&gt; a wallet from the address is used
        Some(contract.clone()),
    )?
    .finish()?;

// Sign the transaction and finalize it
let signatures_added = signer.sign(&amp;mut pset).expect("signing failed");
let _ = wollet.finalize(&amp;mut pset)?;
let tx = pset.extract_tx()?;

// Broadcast the transaction
let txid = client.broadcast(&amp;tx)?;

let asset_id = pset.inputs()[0].issuance_ids().0;
let token_id = pset.inputs()[0].issuance_ids().1;</code></pre>
</section>
<div slot="title">Python</div>
<section>
<pre><code class="language-python">network = Network.regtest_default()
policy_asset = network.policy_asset()
client = ElectrumClient.from_url(node.electrum_url())

# Create wallet
mnemonic = Mnemonic("abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon about")

signer = Signer(mnemonic, network)
desc = signer.wpkh_slip77_descriptor()

wollet = Wollet(network, desc, datadir=None)
wollet_address_result = wollet.address(0)
wollet_adddress = wollet_address_result.address()


contract = Contract(
    domain = "ciao.it", \
    issuer_pubkey = "0337cceec0beea0232ebe14cba0197a9fbd45fcf2ec946749de920e71434c2b904", \
    name = "name", \
    precision = 8, 
    ticker = "TTT", 
    version = 0)

issued_asset = 10000
reissuance_tokens = 1

# Create an issuance transaction 
builder = network.tx_builder()
builder.issue_asset(issued_asset, wollet_adddress, reissuance_tokens, wollet_adddress, contract)
unsigned_pset = builder.finish(wollet)
# Sign the transaction and finalize it
signed_pset = signer.sign(unsigned_pset)
finalized_pset = wollet.finalize(signed_pset)
tx = finalized_pset.extract_tx()

# Broadcast the transaction
txid = client.broadcast(tx)

asset_id = signed_pset.inputs()[0].issuance_asset()
token_id = signed_pset.inputs()[0].issuance_token()
</code></pre>
</section>
</custom-tabs>
<h2 id="important-notes"><a class="header" href="#important-notes">Important Notes</a></h2>
<ul>
<li><strong>Asset amount limit</strong>: The maximum asset amount is 21,000,000 BTC (2,100,000,000,000,000 satoshis)</li>
<li><strong>At least one amount required</strong>: Either <code>asset_sats</code> or <code>token_sats</code> must be greater than 0</li>
<li><strong>Reissuance tokens</strong>: If you want to be able to create more of the asset later, you must issue at least 1 reissuance token. The holder of the reissuance token can use it to <a href="reissuance.html">reissue</a> more of the asset</li>
<li><strong>Contract commitment</strong>: If a contract is provided, its metadata is committed in the asset ID. This means the asset ID will be the same if you use the same contract and transaction input</li>
<li><strong>Confidential issuance</strong>: The issuance amounts can be confidential (blinded) or explicit. LWK handles this automatically</li>
</ul>
<h2 id="next-steps"><a class="header" href="#next-steps">Next Steps</a></h2>
<p>After issuing an asset, you can:</p>
<ul>
<li><a href="reissuance.html">Reissue</a> more of the asset if you have reissuance tokens</li>
<li><a href="burn.html">Burn</a> some of the asset to reduce the supply</li>
<li>Send the asset to other addresses using regular <a href="tx.html">transaction creation</a></li>
</ul>
<hr />
<p>Next: <a href="reissuance.html">Reissuance</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="reissuance"><a class="header" href="#reissuance">Reissuance</a></h1>
<p>Asset reissuance on Liquid allows you to create additional units of an existing asset by spending a reissuance token. When you issue an asset, you can optionally create reissuance tokens that give the holder the right to create more of that asset in the future</p>
<p>The reissuance token is moved when you reissue the asset and you can reissue multiple times as long as you have reissuance tokens available.</p>
<p>To reissue an asset, use <code>TxBuilder::reissue_asset()</code> before calling <code>finish()</code>. The reissuance token must be owned by the wallet generating the reissuance transaction.</p>
<p>The <code>reissue_asset()</code> method takes the following arguments:</p>
<ol>
<li><strong><code>asset_to_reissue</code></strong> (<code>AssetId</code>): The ID of the asset you want to reissue. This is obtained from the original issuance transaction.</li>
<li><strong><code>satoshi_to_reissue</code></strong> (<code>u64</code>): The number of new units (in satoshis) of the asset to create. Must be greater than 0 and cannot exceed 21,000,000 BTC (2,100,000,000,000,000 satoshis).</li>
<li><strong><code>asset_receiver</code></strong> (<code>Option&lt;Address&gt;</code>): Optional address that will receive the newly reissued asset. If <code>None</code>, the asset will be sent to an address from the wallet generating the reissuance transaction.</li>
<li><strong><code>issuance_tx</code></strong> (<code>Option&lt;Transaction&gt;</code>): Optional original issuance transaction. Required only if the wallet generating the reissuance didn't participate in the original issuance (i.e., the reissuance token was transferred to this wallet).</li>
</ol>
<custom-tabs category="lang">
<div slot="title">Rust</div>
<section>
<pre><code class="language-rust ignore">let reissue_asset = 100;
let asset_receiver = None; // Send the asset to the wollet creating the PSET
let issuance_tx = None; // issunce transaction is present in the same wallet
let builder = wollet.tx_builder();
let mut pset = builder
    .reissue_asset(asset_id, reissue_asset, asset_receiver, issuance_tx)?
    .finish()?;
let signatures_added = signer.sign(&amp;mut pset).unwrap();
let _ = wollet.finalize(&amp;mut pset).unwrap();
let tx = pset.extract_tx().unwrap();
let txid = client.broadcast(&amp;tx).unwrap();</code></pre>
</section>
<div slot="title">Python</div>
<section>
<pre><code class="language-python">reissue_asset = 100
asset_receiver = None  # Send the asset to the wollet creating the PSET
issuance_tx = None # issunce transaction is present in the same wallet
builder = network.tx_builder()
builder.reissue_asset(asset_id, reissue_asset, asset_receiver, issuance_tx)
unsigned_pset = builder.finish(wollet)
signed_pset = signer.sign(unsigned_pset)
finalized_pset = wollet.finalize(signed_pset)
tx = finalized_pset.extract_tx()
txid = client.broadcast(tx)
</code></pre>
</section>
</custom-tabs>
<h2 id="next-steps-1"><a class="header" href="#next-steps-1">Next Steps</a></h2>
<p>After reissuing an asset, you can:</p>
<ul>
<li>Reissue again if you have more reissuance tokens</li>
<li><a href="burn.html">Burn</a> some of the asset to reduce the supply</li>
<li>Send the asset to other addresses using regular <a href="tx.html">transaction creation</a></li>
</ul>
<hr />
<p>Previous: <a href="issuance.html">Issuance</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="burn"><a class="header" href="#burn">Burn</a></h1>
<p>Asset burning on Liquid allows you to provably destroy units of an asset, reducing the total supply. This is useful for various purposes such as token buybacks, reducing inflation, or implementing deflationary mechanisms.</p>
<p>When you burn an asset, the units are permanently removed from circulation and cannot be recovered. The burn operation creates a special output in the transaction that destroys the specified amount of the asset.</p>
<p>To burn an asset, use <code>TxBuilder::add_burn()</code> before calling <code>finish()</code>. The asset must be owned by the wallet generating the burn transaction.</p>
<p>The <code>add_burn()</code> method takes the following arguments:</p>
<ol>
<li><strong><code>satoshi</code></strong> (<code>u64</code>): The number of units (in satoshis) of the asset to burn. Must be greater than 0.</li>
<li><strong><code>asset</code></strong> (<code>AssetId</code>): The ID of the asset you want to burn. This is obtained from the original issuance transaction or from your wallet's balance.</li>
</ol>
<custom-tabs category="lang">
<div slot="title">Rust</div>
<section>
<pre><code class="language-rust ignore">let burn_asset = 50;
let builder = wollet.tx_builder();
let mut pset = builder.add_burn(burn_asset, asset_id)?.finish()?;
let signatures_added = signer.sign(&amp;mut pset)?;
let _ = wollet.finalize(&amp;mut pset)?;
let tx = pset.extract_tx()?;
let txid = client.broadcast(&amp;tx)?;</code></pre>
</section>
<div slot="title">Python</div>
<section>
<pre><code class="language-python">burn_asset = 50
builder = network.tx_builder()
builder.add_burn(burn_asset, asset_id)
unsigned_pset = builder.finish(wollet)
signed_pset = signer.sign(unsigned_pset)
finalized_pset = wollet.finalize(signed_pset)
tx = finalized_pset.extract_tx()
txid = client.broadcast(tx)
</code></pre>
</section>
</custom-tabs>
<h2 id="next-steps-2"><a class="header" href="#next-steps-2">Next Steps</a></h2>
<p>After burning an asset, you can:</p>
<ul>
<li><a href="reissuance.html">Reissue</a> the asset if you have reissuance tokens available</li>
<li>Send the remaining asset to other addresses using regular <a href="tx.html">transaction creation</a></li>
</ul>
<hr />
<p>Previous: <a href="reissuance.html">Reissuance</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="manual-coin-selection"><a class="header" href="#manual-coin-selection">Manual Coin Selection</a></h1>
<p>Manual coin selection allows you to explicitly choose which UTXOs (unspent transaction outputs) from your wallet to use when building a transaction. By default, LWK automatically add all UTXOs to cover the transaction amount and fees. However, manual coin selection gives you control over which specific UTXOs are spent, which can be useful for privacy, UTXO management, or specific transaction requirements.</p>
<p>When you enable manual coin selection, only the UTXOs you specify will be used. The transaction builder will not automatically add additional UTXOs, so you must ensure the selected UTXOs provide sufficient funds to cover the transaction amount and fees.</p>
<p>To use manual coin selection, first retrieve the available UTXOs from your wallet using <code>Wollet::utxos()</code>, then call <code>TxBuilder::set_wallet_utxos()</code> before calling <code>finish()</code>. The selected UTXOs must belong to the wallet generating the transaction.</p>
<p>The <code>set_wallet_utxos()</code> method takes the following argument:</p>
<ol>
<li><strong><code>utxos</code></strong> (<code>Vec&lt;OutPoint&gt;</code>): A vector of outpoints (transaction ID and output index) identifying the UTXOs to use. Each outpoint must correspond to a UTXO owned by the wallet.</li>
</ol>
<h2 id="getting-available-utxos"><a class="header" href="#getting-available-utxos">Getting Available UTXOs</a></h2>
<p>Before selecting UTXOs manually, you need to retrieve the list of available UTXOs from your wallet:</p>
<custom-tabs category="lang">
<div slot="title">Rust</div>
<section>
<pre><code class="language-rust ignore">let utxos = w.wollet.utxos()?;</code></pre>
</section>
<div slot="title">Python</div>
<section>
<pre><code class="language-python">utxos = wollet.utxos()
</code></pre>
</section>
</custom-tabs>
<h2 id="manual-coin-selection-for-l-btc"><a class="header" href="#manual-coin-selection-for-l-btc">Manual Coin Selection for L-BTC</a></h2>
<p>The simplest use case is selecting specific L-BTC UTXOs for a transaction:</p>
<custom-tabs category="lang">
<div slot="title">Rust</div>
<section>
<pre><code class="language-rust ignore">let sent_satoshi = 200_000;
let mut pset = w
    .tx_builder()
    .add_recipient(&amp;node_address, sent_satoshi, policy_asset)?
    .set_wallet_utxos(vec![utxos[0].outpoint])
    .finish()?;
signer.sign(&amp;mut pset)?;

// Broadcast the transaction
let tx = w.wollet.finalize(&amp;mut pset).unwrap();
let tx = serialize(&amp;tx);</code></pre>
</section>
<div slot="title">Python</div>
<section>
<pre><code class="language-python">builder = network.tx_builder()
builder.add_lbtc_recipient(node_address, sent_satoshi)
builder.set_wallet_utxos([utxos[0].outpoint()])
unsigned_pset = builder.finish(wollet)


signed_pset = signer.sign(unsigned_pset)
finalized_pset = wollet.finalize(signed_pset)


tx = finalized_pset.extract_tx()
</code></pre>
</section>
</custom-tabs>
<h2 id="manual-coin-selection-with-assets"><a class="header" href="#manual-coin-selection-with-assets">Manual Coin Selection with Assets</a></h2>
<p>When sending assets, you must include sufficient L-BTC UTXOs to cover transaction fees. If you only select asset UTXOs without L-BTC, the transaction will fail with an <code>InsufficientFunds</code> error.</p>
<h2 id="next-steps-3"><a class="header" href="#next-steps-3">Next Steps</a></h2>
<p>After learning about manual coin selection, you can:</p>
<ul>
<li>Learn about <a href="external.html">external UTXOs</a> for using UTXOs not in your wallet</li>
<li>Explore <a href="tx.html">transaction creation</a> for other transaction building options</li>
<li>Use <a href="sendall.html">send all funds</a> to automatically select all L-BTC UTXOs</li>
</ul>
<hr />
<p>Previous: <a href="tx.html">Transaction Creation</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="send-all-funds"><a class="header" href="#send-all-funds">Send All Funds</a></h1>
<p>Sending all funds (also called "draining" the wallet) allows you to send all LBTC (policy asset) from your wallet to a specified address in a single transaction. This is useful when you want to empty your wallet, consolidate UTXOs, or transfer all funds to another address.</p>
<p>When you drain a wallet, all available LBTC UTXOs are selected as inputs, and after deducting transaction fees, the remaining amount is sent to the destination address. Note that draining only affects LBTC (the policy asset).</p>
<p>"Drain" is only available for the asset used to pay fees (LBTC) with. For LBTC it's hard to guess the right amount to send all funds: it's the sum of all LBTC inputs minus the fee, but you don't know the actual fee until you created the transaction. So we need a way specify the TxBuilder to send all LBTC.</p>
<p>For assets that are not LBTC, the caller can easily compute the sum of all asset in input and set the satoshi value explicitly.</p>
<p>To send all LBTC, use <code>TxBuilder::drain_lbtc_wallet()</code>. By default LBTC are sent to a wallet address, if you want specify the destination address use <code>TxBuilder::drain_lbtc_to()</code>.</p>
<p>The methods take the following arguments:</p>
<ol>
<li><strong><code>drain_lbtc_wallet()</code></strong>: No arguments. Selects all available LBTC UTXOs from the wallet to be spent.</li>
<li><strong><code>drain_lbtc_to(address)</code></strong>: Takes an <code>Address</code> parameter specifying where to send all the LBTC after fees are deducted.</li>
</ol>
<custom-tabs category="lang">
<div slot="title">Rust</div>
<section>
<pre><code class="language-rust ignore">let address = env.elementsd_getnewaddress();
let mut pset = wollet
    .tx_builder()
    .drain_lbtc_wallet()
    .drain_lbtc_to(address.clone())
    .finish()?;</code></pre>
</section>
<div slot="title">Python</div>
<section>
<pre><code class="language-python">node_addr = node.get_new_address()
builder = network.tx_builder()
builder.drain_lbtc_wallet()
builder.drain_lbtc_to(node_addr)
pset = builder.finish(w1)
</code></pre>
</section>
</custom-tabs>
<h2 id="next-steps-4"><a class="header" href="#next-steps-4">Next Steps</a></h2>
<p>After sending all funds, you can:</p>
<ul>
<li>Send other assets using regular <a href="tx.html">transaction creation</a></li>
<li>Receive new funds at any address in your wallet</li>
</ul>
<hr />
<p>Previous: <a href="burn.html">Burn</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="amp0-in-lwk"><a class="header" href="#amp0-in-lwk">AMP0 in LWK</a></h1>
<p><a href="https://blockstream.com/amp/">AMP0</a> (Asset Management Platform version 0) is a service for issuers that allows to enforce specific rules on certain Liquid assets (AMP0 assets).</p>
<p>AMP0 is based on a legacy system and it does not fit the LWK model perfectly.
That is reflected in the LWK AMP0 interface which could be a bit cumbersome to use.</p>
<h2 id="limitations"><a class="header" href="#limitations">Limitations</a></h2>
<p><em>LWK has partial support for AMP0.</em>
For instance it does not allow to issue AMP0 asset, or use accounts with 2FA.</p>
<div class="table-wrapper"><table><thead><tr><th></th><th style="text-align: center">LWK</th><th style="text-align: center">GDK</th><th style="text-align: center">AMP0 API</th></tr></thead><tbody>
<tr><td>Create AMP0 accounts</td><td style="text-align: center">‚úÖ</td><td style="text-align: center">‚úÖ</td><td style="text-align: center">‚ùå</td></tr>
<tr><td>Receive on AMP0 accounts</td><td style="text-align: center">‚úÖ</td><td style="text-align: center">‚úÖ</td><td style="text-align: center">‚ùå</td></tr>
<tr><td>Monitor AMP0 accounts</td><td style="text-align: center">‚úÖ</td><td style="text-align: center">‚úÖ</td><td style="text-align: center">‚ùå</td></tr>
<tr><td>Send from AMP0 accounts</td><td style="text-align: center">‚úÖ</td><td style="text-align: center">‚úÖ</td><td style="text-align: center">‚ùå</td></tr>
<tr><td>Account with 2FA</td><td style="text-align: center">‚ùå</td><td style="text-align: center">‚úÖ</td><td style="text-align: center">‚ùå</td></tr>
<tr><td>issue, reissue, burn AMP0 assets</td><td style="text-align: center">‚ùå</td><td style="text-align: center">‚ùå</td><td style="text-align: center">‚úÖ</td></tr>
<tr><td>set restriction for AMP0 assets</td><td style="text-align: center">‚ùå</td><td style="text-align: center">‚ùå</td><td style="text-align: center">‚úÖ</td></tr>
</tbody></table>
</div>
<p>If you need full support for AMP0, use <a href="https://github.com/blockstream/gdk">GDK</a> and the AMP0 issuer API.</p>
<h2 id="overview"><a class="header" href="#overview">Overview</a></h2>
<p>To use AMP0 with LWK you need:</p>
<ul>
<li>üëÄ some Green Watch-Only credentials (username and password) for a Green Wallet with an AMP account</li>
<li>üîë the corresponding signer available (e.g. Jade or software with the BIP39 mnemonic)</li>
</ul>
<p>Then you can:</p>
<ul>
<li>get addresses for the AMP0 account (üëÄ)</li>
<li>monitor the AMP0 account (get balance and transactions) (üëÄ)</li>
<li>create AMP0 transactions (üëÄ)</li>
<li>sign AMP0 transactions (üîë)</li>
<li>ask AMP0 to cosign transactions (üëÄ)</li>
<li>broadcast AMP0 transactions (üëÄ)</li>
</ul>
<p>Using AMP0 with LWK you can keep the signer separated and operate it accoriding to the desired degree of security and isolation.</p>
<div class="warning">
‚ö†Ô∏è AMP0 is based on a legacy system and it has some pitfalls.
We put some mechanism in order to make it harder to do the wrong thing, anyway callers should be careful when getting new addresses and syncing the wallet.
</div>
<h2 id="setup-1"><a class="header" href="#setup-1">Setup</a></h2>
<p>To use AMP0 with LWK you need to:</p>
<ol>
<li>Create a Liquid wallet (backup its mnemonic/seed)</li>
<li>Create an AMP account (AMP ID)</li>
<li>Create a Liquid Watch-Only (username and password)</li>
</ol>
<h3 id="1-create-liquid-wallet"><a class="header" href="#1-create-liquid-wallet">1. Create Liquid wallet</a></h3>
<p>Create a <code>Signer</code> and backup it's mnemonic/seed.
From the signer get its <code>signer_data</code> using <code>Signer::amp0_signer_data()</code>.</p>
<p>Create a <code>Amp0Connected::new()</code> passing the <code>signer_data</code>.
You now need to authenticate with AMP0 server.
First get the server challenge with <code>Amp0Connected::get_challenge()</code>.
Sign the challenge with <code>Signer::amp0_sign_challenge()</code>.
You can now call <code>Amp0Connected::login()</code> passing the signature.
This function returns a <code>Amp0LoggedIn</code> instance, which can be used to create new AMP0 accounts and watch-only entries.</p>
<h3 id="2-create-an-amp-account"><a class="header" href="#2-create-an-amp-account">2. Create an AMP account</a></h3>
<p>Obtain the number of the next account using <code>Amp0LoggedIn::next_account()</code>.
Use the signer to get the corresponding xpub <code>Signer::amp0_accont_xpub()</code>.
Now you can create a new AMP0 account with <code>Amp0LoggedIn::create_amp0_account()</code>, which returns the AMP ID.</p>
<h3 id="3-create-a-liquid-watch-only"><a class="header" href="#3-create-a-liquid-watch-only">3. Create a Liquid Watch-Only</a></h3>
<p>Choose your your AMP0 Watch-Only credentials <code>username</code> and <code>password</code> and call <code>Amp0LoggedIn::create_watch_only()</code>.</p>
<p>Now that you have mnemonic/seed (or Jade), AMP ID and Watch-Only credentials (username and password), you're ready to use AMP0 with LWK.</p>
<blockquote>
<p>If you're using <code>lwk_node</code>, polyfill the websocket</p>
<pre><code class="language-typescript">const WebSocket = require('ws');
global.WebSocket = WebSocket;
const lwk = require('lwk_node');
</code></pre>
</blockquote>
<custom-tabs category="lang">
<div slot="title">Rust</div>
<section>
<pre><code class="language-rust ignore"></code></pre>
</section>
<div slot="title">Python</div>
<section>
<pre><code class="language-python"># Create signer and watch only credentials
username = "&lt;username&gt;";
password = "&lt;password&gt;";
mnemonic = "&lt;mnemonic&gt;";

network = Network.testnet()
signer = Signer(mnemonic, network)

# Collect signer data
signer_data = signer.amp0_signer_data();

# Connect to AMP0
amp0 = Amp0Connected(network, signer_data);

# Obtain and sign the authentication challenge
challenge = amp0.get_challenge();
sig = signer.amp0_sign_challenge(challenge);

# Login
amp0 = amp0.login(sig);

# Create a new AMP0 account
pointer = amp0.next_account();
account_xpub = signer.amp0_account_xpub(pointer);
amp_id = amp0.create_amp0_account(pointer, account_xpub);

# Create watch only entries
amp0.create_watch_only(username, password);

# Use watch only credentials to interact with AMP0
amp0 = Amp0(network, username, password, amp_id);
</code></pre>
</section>
<div slot="title">Javascript</div>
<section>
<pre><code class="language-typescript">const mnemonic = "&lt;mnemonic&gt;";
const m = new lwk.Mnemonic(mnemonic);
const network = lwk.Network.testnet();
const signer = new lwk.Signer(m, network);
const username = "&lt;username&gt;";
const password = "&lt;password&gt;";

// Collect signer data
const signer_data = signer.amp0SignerData();
// Connect to AMP0
const amp0connected = await new lwk.Amp0Connected(network, signer_data);
// Obtain and sign the authentication challenge
const challenge = await amp0connected.getChallenge();
const sig = signer.amp0SignChallenge(challenge);
// Login
const amp0loggedin = await amp0connected.login(sig);
// Create a new AMP0 account
const pointer = amp0loggedin.nextAccount();
const account_xpub = signer.amp0AccountXpub(pointer);
const amp_id = await amp0loggedin.createAmp0Account(pointer, account_xpub);
// Create watch only entries
await amp0loggedin.createWatchOnly(username, password);
// Use watch only credentials to interact with AMP0
const amp0 = await new lwk.Amp0(network, username, password, amp_id);
</code></pre>
</section>
</custom-tabs>
<h3 id="alternative-setup"><a class="header" href="#alternative-setup">Alternative setup</a></h3>
<p>It's possible to setup an AMP0 account using GDK based apps:</p>
<ol>
<li><a href="https://blockstream.com/app/">Blockstream App</a> (easiest, GUI, mobile, desktop, Jade support), or</li>
<li><a href="https://github.com/Blockstream/green_cli/"><code>green_cli</code></a> (CLI, Jade support), or</li>
<li><a href="https://github.com/blockstream/gdk">GDK</a> directly (fastest, <a href="gdk-amp0.py">example</a>)</li>
</ol>
<h2 id="amp0-daily-operations"><a class="header" href="#amp0-daily-operations">AMP0 daily operations</a></h2>
<p>LWK allows to manage created AMP0 accounts.
You can receive funds, monitor transactions and send to other wallets.</p>
<h3 id="receive"><a class="header" href="#receive">Receive</a></h3>
<p>To receive funds you need an address, you can get addresses with <code>Amp0::address()</code>.</p>
<div class="warning">
‚ö†Ô∏è For AMP0 wallets, do not use <code>Wollet::address()</code> or <code>WolletDescriptor::address()</code>, using them can lead to loss of funds.
AMP0 server only monitors addresses that have been returned by the server.
If you send funds to an address that was not returned by the server, the AMP0 server will not cosign transactions spending that inputs.
Which means that those funds are lost (!), since AMP0 accounts are 2of2.
</div>
<h3 id="monitor"><a class="header" href="#monitor">Monitor</a></h3>
<p>LWK allows to monitor Liquid wallets, including AMP0 accounts.</p>
<p>First you get the AMP0 descriptor with <code>Amp0::wollet_descriptor()</code>.
You then create a wallet with <code>Wollet::new()</code>.</p>
<p>Once you have the AMP0 <code>Wollet</code>, you can get <code>Wollet::transactions()</code>, <code>Wollet::balance()</code> and other information.</p>
<p>LWK wallets needs to be updated with new data from the Liquid blockchain.
First create a blockchain client, for insance <code>EsploraClient::new()</code>.
Then get an update with <code>BlockchainBackend::full_scan_to_index()</code> passing the value returned by <code>Amp0::last_index()</code>.
Finally update the wallet with <code>Wollet::apply_update()</code>.</p>
<div class="warning">
‚ö†Ô∏è For AMP0 wallets, do not sync the wallet with <code>BlockchainBackend::full_scan()</code>, otherwise some funds might not show up.
AMP0 accounts do not have the concept of <code>GAP_LIMIT</code> and they can have several unused address in a row.
The default scanning mechanism when it sees enough unused addresses in a row it stops.
So it can happen that some transactions are not returned, and the wallet balance could be incorrect.
</div>
<h3 id="send-1"><a class="header" href="#send-1">Send</a></h3>
<p>For AMP0 you can follow the standard LWK transaction flow, with few small differences.</p>
<p>Use the <code>TxBuilder</code>, add recipients <code>TxBuilder::add_recipient()</code>, and use the other available methods if needed.</p>
<p>Then instead of using <code>TxBuilder::finish()</code>, use <code>TxBuilder::finish_for_amp0()</code>.
This creates an <code>Amp0Pset</code> which contains the PSET and the <code>blinding_nonces</code>, some extra data needed by the AMP0 cosigner.</p>
<p>Now you need to interact with secret key material (üîë) corresponding to this AMP0 account.
Create a signer, using <code>SWSigner</code> or <code>Jade</code> and sign the PSET with the signer, using <code>Signer::sign()</code>.</p>
<p>Once the PSET is signed, you need to have it cosigned by AMP0.
Construct an <code>Amp0Pset</code> using the signed PSET and the <code>blinding_nonces</code> obtained before.
Call <code>Amp0::sign()</code> passing the signed <code>Amp0Pset</code>.</p>
<p>If all the AMP0 rules are respected, the transaction is cosigned by AMP0 and can be broadcast, e.g. with <code>EsploraClient::broadcast()</code>.</p>
<custom-tabs category="lang">
<div slot="title">Rust</div>
<section>
<pre><code class="language-rust ignore"></code></pre>
</section>
<div slot="title">Python</div>
<section>
<pre><code class="language-python"># Signer
mnemonic = "&lt;mnemonic&gt;";
# AMP0 Watch-Only credentials
username = "&lt;username&gt;";
password = "&lt;password&gt;";
# AMP ID (optional)
amp_id = "";

# Create AMP0 context
network = Network.testnet()

amp0 = Amp0(network, username, password, amp_id);

# Create AMP0 Wollet
wollet_descriptor = amp0.wollet_descriptor()
wollet = Wollet(network, wollet_descriptor, None)

# Get a new address
addr = str(amp0.address(None).address());

# Update the wallet with (new) blockchain data
url = "https://waterfalls.liquidwebwallet.org/liquidtestnet/api";
client = EsploraClient.new_waterfalls(url, network)
last_index = amp0.last_index()
update = client.full_scan_to_index(wollet, last_index)
wollet.apply_update(update)

# Get balance
balance = wollet.balance()

# Construct a PSET sending LBTC back to the wallet
b = network.tx_builder()
b.drain_lbtc_wallet()  # send all to self
amp0pset = b.finish_for_amp0(wollet)

# User signs the PSET
signer = Signer(Mnemonic(mnemonic), network)
pset = amp0pset.pset()
pset = signer.sign(pset)

# Reconstruct the Amp0 PSET with the PSET signed by the user
amp0pset = Amp0Pset(pset, amp0pset.blinding_nonces())

# AMP0 signs
tx = amp0.sign(amp0pset)

# Broadcast the transaction
txid = client.broadcast(tx)
</code></pre>
</section>
<div slot="title">Javascript</div>
<section>
<pre><code class="language-typescript">const mnemonic = "&lt;mnemonic&gt;";
const m = new lwk.Mnemonic(mnemonic);
const network = lwk.Network.testnet();
const signer = new lwk.Signer(m, network);
const username = "&lt;username&gt;";
const password = "&lt;password&gt;";
const amp_id = "";

// Create AMP0 object
const amp0 = await lwk.Amp0.newTestnet(username, password, amp_id);

// Get an address
const addrResult = await amp0.address(1);

// Create wollet
const wollet = amp0.wollet();

// Sync the wallet
const url = "https://waterfalls.liquidwebwallet.org/liquidtestnet/api";
const client = new lwk.EsploraClient(network, url, true, 4, false);

const last_index = amp0.lastIndex();
const update = await client.fullScanToIndex(wollet, last_index);
if (update) {
    wollet.applyUpdate(update);
}

// Get the wallet transactions
const txs = wollet.transactions();

// Get the balance
const balance = wollet.balance();

// Create a (redeposit) transaction
var b = network.txBuilder();
b = b.drainLbtcWallet();
const amp0pset = b.finishForAmp0(wollet);

// Sign with the user key
const pset = amp0pset.pset();
const signed_pset = signer.sign(pset);

// Ask AMP0 to cosign
const amp0pset_signed = new lwk.Amp0Pset(signed_pset, amp0pset.blindingNonces());
const tx = await amp0.sign(amp0pset_signed);

// Broadcast
const txid = await client.broadcastTx(tx);
</code></pre>
</section>
</custom-tabs>
<h2 id="examples"><a class="header" href="#examples">Examples</a></h2>
<p>We provide a few examples on how to integrate use AMP0 with LWK:</p>
<ul>
<li><a href="https://liquidwebwallet.org">liquidwebwallet.org</a> integrates AMP0 using WASM</li>
<li>Rust tests in <a href="../lwk_wollet/src/amp0.rs">amp0.rs</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="liquidex"><a class="header" href="#liquidex">LiquiDEX</a></h1>
<p>LiquiDEX is a 2-step atomic swap protocol for the Liquid Network that enables trustless peer-to-peer asset exchanges. It allows users to swap Liquid Bitcoin (LBTC) and other Liquid assets without requiring a trusted third party or centralized exchange.</p>
<h2 id="overview-1"><a class="header" href="#overview-1">Overview</a></h2>
<p>A LiquiDEX swap involves two parties:</p>
<ul>
<li><strong>Maker</strong>: Creates a swap proposal offering to exchange one asset for another</li>
<li><strong>Taker</strong>: Accepts the proposal and completes the swap</li>
</ul>
<p>The protocol uses an incomplete but signed transaction (unbalanced and without fees) created by the maker. The taker completes the transaction by adding inputs and outputs, balancing the amounts and adding fees. This ensures atomicity: either both parties get what they want, or the transaction cannot be broadcast.</p>
<p>The proposal always spend a full utxo, due there is no a way to add change address for the <strong>maker</strong>.</p>
<h2 id="how-it-works"><a class="header" href="#how-it-works">How It Works</a></h2>
<ol>
<li>
<p><strong>Maker creates a proposal</strong>: The maker creates a PSET with one input (UTXO to be spent) and one output (the asset he want to receive). The transaction is signed but incomplete. The PSET is comverted in a Liquid Proposal, a structure cointaining all the relevant information for the swap.</p>
</li>
<li>
<p><strong>Proposal validation</strong>: The taker receives the proposal and validates it using primitives available in LWK.</p>
</li>
<li>
<p><strong>Taker completes the swap</strong>: The taker recerate the PSET and adds inputs and outputs to balance the transaction, adds fees, and signs their part.</p>
</li>
<li>
<p><strong>Transaction broadcast</strong>: The completed transaction is broadcast to the Liquid Network, executing the atomic swap.</p>
</li>
</ol>
<h2 id="key-concepts"><a class="header" href="#key-concepts">Key Concepts</a></h2>
<h3 id="liquidexproposal"><a class="header" href="#liquidexproposal">LiquidexProposal</a></h3>
<p>A <code>LiquidexProposal</code> represents a swap offer. It comes in two states:</p>
<ul>
<li><strong>Unvalidated</strong>: The proposal has been created but not yet verified</li>
<li><strong>Validated</strong>: The proposal has been verified and is ready to be taken</li>
</ul>
<h2 id="creating-a-swap-proposal-maker"><a class="header" href="#creating-a-swap-proposal-maker">Creating a Swap Proposal (Maker)</a></h2>
<p>The maker creates a swap proposal by building a transaction with <code>liquidex_make()</code>, signing it, and converting it to a proposal:</p>
<custom-tabs category="lang">
<div slot="title">Rust</div>
<section>
<pre><code class="language-rust ignore">// LiquiDEX make
let addr = wallet_maker.address_result(None).address().clone();
let mut pset = wallet_maker
    .tx_builder()
    .liquidex_make(utxo_send, &amp;addr, sats_recv, asset_recv)
    .unwrap()
    .finish()
    .unwrap();

let details = wallet_maker.wollet.get_details(&amp;pset).unwrap();

wallet_maker.sign(signer_maker, &amp;mut pset);
let proposal = LiquidexProposal::from_pset(&amp;pset).unwrap();</code></pre>
</section>
<div slot="title">Python</div>
<section>
<pre><code class="language-python"># (maker) Create a liquidex proposal (asking for the issued asset in exchange for the policy asset)
builder = network.tx_builder()
utxo = maker.utxos()[0].outpoint()
builder.liquidex_make(utxo, maker.address(None).address(), issued_asset_units, asset)
pset = builder.finish(maker)
signed_pset = signer.sign(pset)

# (maker) Create the proposal  and convert it to string to pass it to the taker
proposal = UnvalidatedLiquidexProposal.from_pset(signed_pset)
proposal_str = str(proposal)
</code></pre>
</section>
</custom-tabs>
<h2 id="validating-a-proposal-taker"><a class="header" href="#validating-a-proposal-taker">Validating a Proposal (Taker)</a></h2>
<p>Before accepting a proposal, the taker must validate it by fetching the previous transaction and verifying the proposal:</p>
<custom-tabs category="lang">
<div slot="title">Rust</div>
<section>
<pre><code class="language-rust ignore">let txid = proposal.needed_tx().unwrap();
let tx = wallet_maker.wollet.transaction(&amp;txid).unwrap().unwrap().tx;
let proposal = proposal.validate(tx).unwrap();</code></pre>
</section>
<div slot="title">Python</div>
<section>
<pre><code class="language-python"># (taker) Parse the proposal from string and validate it
proposal_from_str = UnvalidatedLiquidexProposal(proposal_str)
txid = proposal_from_str.needed_tx()
previous_tx = client.get_tx(txid)
validated_proposal = proposal_from_str.validate(previous_tx)
</code></pre>
</section>
</custom-tabs>
<h2 id="taking-a-proposal-taker"><a class="header" href="#taking-a-proposal-taker">Taking a Proposal (Taker)</a></h2>
<p>Once validated, the taker can accept the proposal by using <code>liquidex_take()</code> to complete the transaction:</p>
<custom-tabs category="lang">
<div slot="title">Rust</div>
<section>
<pre><code class="language-rust ignore">// LiquiDEX take
let mut pset = wallet_taker
    .tx_builder()
    .liquidex_take(vec![proposal])
    .unwrap()
    .finish()
    .unwrap();
wallet_taker.sign(signer_taker, &amp;mut pset);
let _txid = wallet_taker.send(&amp;mut pset);</code></pre>
</section>
<div slot="title">Python</div>
<section>
<pre><code class="language-python"># (taker) Accept the proposal
builder2 = network.tx_builder()
builder2.liquidex_take([validated_proposal])
pset2 = builder2.finish(taker)
signed_pset2 = signer2.sign(pset2)

# (taker) Finalize and broadcast the transaction
finalized_pset = taker.finalize(signed_pset2)
tx = finalized_pset.extract_tx()
txid = client.broadcast(tx)
</code></pre>
</section>
</custom-tabs>
<h2 id="additional-resources"><a class="header" href="#additional-resources">Additional Resources</a></h2>
<ul>
<li><a href="https://blog.blockstream.com/liquidex-2-step-atomic-swaps-on-the-liquid-network/">LiquiDEX Blog Post</a></li>
</ul>
<hr />
<p>Previous: <a href="ledger.html">Ledger</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="bip85"><a class="header" href="#bip85">BIP85</a></h1>
<p>The <a href="https://github.com/bitcoin/bips/blob/master/bip-0085.mediawiki">BIP85 specification</a> allows you to deterministically derive new BIP39 mnemonics from an existing mnemonic. This is useful for creating separate wallets or accounts while maintaining a single backup.</p>
<h2 id="deriving-a-mnemonic"><a class="header" href="#deriving-a-mnemonic">Deriving a Mnemonic</a></h2>
<p>To derive a BIP85 mnemonic, you need a software signer initialized with a mnemonic (hardware wallet-based signers are not supported at the moment). The derived mnemonic is obtained with <code>Signer::derive_bip85_mnemonic()</code>, which takes an <code>index</code> (0-based) and a <code>word_count</code> (12 or 24).</p>
<custom-tabs category="lang">
<div slot="title">Rust</div>
<section>
<pre><code class="language-rust ignore">// Load mnemonic
let mnemonic = "abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon about";

// Create signer
let is_mainnet = false;
let signer = SwSigner::new(mnemonic, is_mainnet)?;

// Derive menmonics
let derived_0_12 = signer.derive_bip85_mnemonic(0, 12)?;
let derived_0_24 = signer.derive_bip85_mnemonic(0, 24)?;
let derived_1_12 = signer.derive_bip85_mnemonic(1, 12)?;</code></pre>
</section>
<div slot="title">Python</div>
<section>
<pre><code class="language-python"># Load mnemonic
test_mnemonic = "abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon about"
mnemonic = Mnemonic(test_mnemonic)

# Create signer
network = Network.testnet()
signer = Signer(mnemonic, network)

# Derive mnemonics
derived_0_12 = signer.derive_bip85_mnemonic(0, 12)
derived_0_24 = signer.derive_bip85_mnemonic(0, 24)
derived_1_12 = signer.derive_bip85_mnemonic(1, 12)
</code></pre>
</section>
<div slot="title">Javascript</div>
<section>
<pre><code class="language-typescript">// Load mnemonic
const mnemonic = new lwk.Mnemonic("abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon about");

// Create signer
const network = lwk.Network.testnet();
const signer = new lwk.Signer(mnemonic, network);
console.log("Signer created");

// Derive menmonics
const derived_0_12 = await signer.derive_bip85_mnemonic(0, 12);
const derived_0_24 = await signer.derive_bip85_mnemonic(0, 24);
const derived_1_12 = await signer.derive_bip85_mnemonic(1, 12);
</code></pre>
</section>
</custom-tabs>
<hr />
<p>Next: <a href="cli.html">CLI</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="lwk-structure"><a class="header" href="#lwk-structure">LWK Structure</a></h1>
<p>LWK functionalities are split into different component crates that might be useful independently.</p>
<ul>
<li><a href="../lwk_cli"><code>lwk_cli</code></a>: a CLI tool to use LWK wallets.</li>
<li><a href="../lwk_wollet"><code>lwk_wollet</code></a>: library for watch-only wallets;
specify a CT descriptor, generate new addresses, get balance,
create PSETs and other actions.</li>
<li><a href="../lwk_signer"><code>lwk_signer</code></a>: interact with Liquid signers
to get your PSETs signed.</li>
<li><a href="../lwk_jade"><code>lwk_jade</code></a>: unlock Jade, get xpubs,
register multisig wallets, sign PSETs and more.</li>
<li><a href="../lwk_bindings"><code>lwk_bindings</code></a>: use LWK from other languages.</li>
<li><a href="../lwk_wasm"><code>lwk_wasm</code></a>: use LWK from WebAssembly.</li>
<li>and more:
common or ancillary components (<a href="../lwk_common"><code>lwk_common</code></a>,
<a href="../lwk_rpc_model"><code>lwk_rpc_model</code></a>, <a href="../lwk_tiny_rpc"><code>lwk_tiny_rpc</code></a>,
<a href="../lwk_app"><code>lwk_app</code></a>),
future improvements (<a href="../lwk_hwi"><code>lwk_hwi</code></a>),
testing infrastructure (<a href="../lwk_test_util"><code>lwk_test_util</code></a>,
<a href="../lwk_containers"><code>lwk_containers</code></a>)</li>
</ul>
<p>For instance, mobile app devs might be interested mainly in
<code>lwk_bindings</code>, <code>lwk_wollet</code> and <code>lwk_signer</code>.
While backend developers might want to directly use <code>lwk_cli</code>
in their systems.</p>
<p>Internal crate dependencies are shown in this diagram: an arrow indicates "depends on" (when dotted the dependency is feature-activated, when blue is a dev-dependency):</p>
<p><img src="./dep-tree.svg" alt="Dep tree" /></p>
<p>(generated with <code>cargo depgraph --workspace-only --dev-deps | dot -Tsvg &gt; docs/src/dep-tree.svg</code>)</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="users-of-lwk"><a class="header" href="#users-of-lwk">Users of LWK</a></h1>
<p>This section showcases a series of projects that are built on LWK or its components.</p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Description</th><th>Type</th><th>Language</th></tr></thead><tbody>
<tr><td><a href="https://liquidtestnet.com">Liquidtestnet.com</a></td><td>Testnet Faucet</td><td>Server</td><td>Python</td></tr>
<tr><td><a href="https://liquidwebwallet.org">Liquidwebwallet.org</a></td><td>Browser wallet</td><td>Wallet</td><td>Wasm</td></tr>
<tr><td><a href="https://amp2.testnet.blockstream.com/info/spec">AMP2</a></td><td>Registered Assets</td><td>Server</td><td>Closed source</td></tr>
<tr><td><a href="https://github.com/breez/breez-sdk-liquid">Breeze SDK Liquid</a></td><td>Lightning swaps</td><td>SDK</td><td>Rust</td></tr>
<tr><td><a href="https://boltz.exchange/">Boltz</a></td><td>Atomic swaps</td><td>Server</td><td>Go</td></tr>
<tr><td><a href="https://aqua.net/">Aqua</a></td><td>Atomic swaps</td><td>Wallet</td><td>Dart</td></tr>
<tr><td><a href="https://wallet.bullbitcoin.com/">Bull Bitcoin</a></td><td>Atomic swaps</td><td>Wallet</td><td>Dart</td></tr>
<tr><td><a href="https://blitz-wallet.com/">Blitz Wallet</a></td><td>Atomic swaps</td><td>Wallet</td><td>Javascript</td></tr>
<tr><td><a href="https://www.peerswap.dev/">Peerswap</a></td><td>LN Balancing</td><td>Server</td><td>Go</td></tr>
<tr><td><a href="https://www.arealayer.net/projects#h.kk9ofahkprw7">AreaLayer FireBolt wallet</a></td><td>Wallet</td><td>Wallet</td><td>TypeScript</td></tr>
<tr><td><a href="https://bancolibre.com/">Banco Libre</a></td><td>Browser wallet</td><td>Wallet</td><td>Wasm</td></tr>
<tr><td><a href="https://breez.technology/">Misty Breeze</a></td><td>Lightning wallet</td><td>Wallet</td><td>Dart</td></tr>
<tr><td><a href="https://blog.onionmill.com/">Onion Mill - StashPay</a></td><td>Lightning wallet</td><td>Wallet</td><td></td></tr>
<tr><td><a href="https://github.com/dev4bitcoin/psetgui/">PSET GUI</a></td><td>PSET Analyzer</td><td>Tool</td><td>JavaScript</td></tr>
<tr><td><a href="https://www.satsails.com/">Satsails</a></td><td>Wallet</td><td>Wallet</td><td>Dart</td></tr>
<tr><td><a href="https://shopstr.store/">Shopstr</a></td><td>Nostr Marketplace</td><td>Server</td><td>TypeScript</td></tr>
</tbody></table>
</div>
<p>Feel free to open a PR to add or remove your product.</p>
<h2 id="liquidtestnetcom"><a class="header" href="#liquidtestnetcom">Liquidtestnet.com</a></h2>
<p><a href="https://liquidtestnet.com">Liquidtestnet.com</a> provides a several utilities to interact with Liquid testnet.
It also has a testnet faucet which distributes testnet assets (LBTC, standard assets and AMP0, AMP2 assets).</p>
<p>The faucet is built using LWK python wheels.</p>
<p>Liquidtestnet.com is open source, source available in the <a href="https://github.com/valerio-vaccaro/liquidtestnet.com">Github repository</a>.</p>
<h2 id="liquidwebwalletorg"><a class="header" href="#liquidwebwalletorg">Liquidwebwallet.org</a></h2>
<p><a href="https://liquidwebwallet.org">Liquidwebwallet.org</a> is a companion app for Liquid running in the browser.
The website allows the use of read-only wallets or hardware wallets such as Jade or Ledger to access one's wallet, view the balance, create transactions, create issuance, reissuance, and burn transactions.</p>
<p>The wallet is built using <a href="https://www.npmjs.com/package/lwk_wasm">LWK_wasm</a>.</p>
<p>Liquidwebwallet.org is open source, source available in the <a href="https://github.com/RCasatta/liquid-web-wallet">Github repository</a></p>
<h2 id="amp2"><a class="header" href="#amp2">AMP2</a></h2>
<p><a href="https://amp2.testnet.blockstream.com/info/spec">AMP2</a> is a platform able to issue and manage digital assets on the Liquid Network with flexible API.
The platform allows for the management of the entire token lifecycle, enabling the control and authorization of each individual operation.</p>
<p>AMP2 uses LWK internally.</p>
<p>AMP2 is closed source.</p>
<h2 id="breeze-sdk-liquid"><a class="header" href="#breeze-sdk-liquid">Breeze SDK Liquid</a></h2>
<p>The <a href="https://github.com/breez/breez-sdk-liquid">Breeze SDK Liquid</a> provides developers with a end-to-end solution for integrating self-custodial Lightning payments into their apps and services.</p>
<p>The SDK use LWK as internal liquid wallet and signer.</p>
<p>Breeze SDK Liquid is open source, source available in the <a href="https://github.com/breez/breez-sdk-liquid">Github repository</a></p>
<h2 id="boltz"><a class="header" href="#boltz">Boltz</a></h2>
<p><a href="https://boltz.exchange/">Boltz</a> the Non-Custodial Bitcoin Bridge able to swap between different Bitcoin layers.</p>
<p>The SDK use LWK as internal liquid wallet and signer.</p>
<p>Boltz is open source, source available in the <a href="https://github.com/BoltzExchange/boltz-client">Github repository</a></p>
<h2 id="aqua"><a class="header" href="#aqua">Aqua</a></h2>
<p><a href="https://aqua.net/">Aqua</a> AQUA is a free, open-source wallet for iOS and Android.</p>
<p>The app use LWK in the backend.</p>
<p>Aqua is open source, source available in the <a href="https://github.com/AquaWallet/aqua-wallet">Github repository</a></p>
<h2 id="bull-bitcoin"><a class="header" href="#bull-bitcoin">Bull Bitcoin</a></h2>
<p><a href="https://wallet.bullbitcoin.com/">Bull Bitcoin</a> is a mobile wallet with Bitcoin, Liquid and lightning support.</p>
<p>Bull Bitcoin uses LWK for its Liquid wallet.</p>
<p>Bull Bitcoin is open source, source available in the <a href="https://github.com/SatoshiPortal/bullbitcoin-mobile">Github repository</a></p>
<h2 id="blitz-wallet"><a class="header" href="#blitz-wallet">Blitz Wallet</a></h2>
<p><a href="https://blitz-wallet.com/">Blitz Wallet</a> is a react native wallet.</p>
<p>The app is based on Breeze SDK Liquid.</p>
<p>Blitz Wallet is open source, source available in the <a href="https://github.com/BlitzWallet/BlitzWallet">Github repository</a></p>
<h2 id="peerswap"><a class="header" href="#peerswap">Peerswap</a></h2>
<p><a href="https://www.peerswap.dev/">Peerswap</a> Atomic swaps for rebalancing Lightning channels.</p>
<p>The app use LWK as internal liquid wallet and signer.</p>
<p>Peerswap is open source, source available in the <a href="https://github.com/ElementsProject/peerswap">Github repository</a></p>
<h2 id="arealayer-firebolt-wallet"><a class="header" href="#arealayer-firebolt-wallet">AreaLayer FireBolt wallet</a></h2>
<p>|<a href="https://www.arealayer.net/projects#h.kk9ofahkprw7">AreaLayer FireBolt wallet</a> is a react native wallet.</p>
<p>The app is based on Breeze SDK Liquid.</p>
<p>AreaLayer FireBolt wallet is open source, source available in the <a href="https://github.com/AreaLayer/firebolt-react-native">Github repository</a></p>
<h2 id="banco-libre"><a class="header" href="#banco-libre">Banco Libre</a></h2>
<p><a href="https://bancolibre.com/">Banco Libre</a> is a web wallet using LWK_wasm.</p>
<p>The app use LWK_wasm as internal liquid wallet and signer.</p>
<p>Banco Libre is open source, source available in the <a href="https://github.com/kipu-org/banco-client">Github repository</a></p>
<h2 id="misty-breeze"><a class="header" href="#misty-breeze">Misty Breeze</a></h2>
<p><a href="https://breez.technology/">Misty Breeze</a> is a flutter app based on Breez SDK Liquid.</p>
<p>The app is based on Breeze SDK Liquid.</p>
<p>Misty Breeze is open source, source available in the <a href="https://github.com/breez/misty-breez">Github repository</a></p>
<h2 id="onion-mill---stashpay"><a class="header" href="#onion-mill---stashpay">Onion Mill - StashPay</a></h2>
<p><a href="https://blog.onionmill.com/">Onion Mill - StashPay</a> is a  minimalist Bitcoin wallet based on Breeze SDK Liquid.</p>
<p>The app is based on Breeze SDK Liquid.</p>
<p>Onion Mill - StashPay is open source, source available in the <a href="https://github.com/onionmill/stashpay-bin">Github repository</a></p>
<h2 id="pset-gui"><a class="header" href="#pset-gui">PSET GUI</a></h2>
<p><a href="https://github.com/dev4bitcoin/psetgui/">PSET GUI</a> is a user-friendly application designed for analyzing and signing PSETs.</p>
<p>The app use LWK_wasm as internal liquid wallet and signer.</p>
<p>PSET GUI is open source, source available in the <a href="https://github.com/dev4bitcoin/psetgui/">Github repository</a></p>
<h2 id="satsails"><a class="header" href="#satsails">Satsails</a></h2>
<p><a href="https://www.satsails.com/">Satsails</a> is a self-custodial Bitcoin and Liquid wallet with support for stablecoins.</p>
<p>The app use LWK_wasm as internal liquid wallet and signer.</p>
<p>Satsails is open source, source available in the <a href="https://github.com/Satsails/Satsails">Github repository</a></p>
<h2 id="shopstr"><a class="header" href="#shopstr">Shopstr</a></h2>
<p><a href="https://shopstr.store/">Shopstr</a> is a global, permissionless Nostr marketplace for Bitcoin commerce.</p>
<p>WIP for <a href="https://github.com/shopstr-eng/shopstr/issues/74">Liquid integration</a></p>
<p>Shopstr is open source, source available in the <a href="https://github.com/shopstr-eng/">Github repository</a></p>
<h1 id="unknown-users"><a class="header" href="#unknown-users">Unknown users</a></h1>
<p>There may be many other users of the libraries who are currently unknown or not publicly disclosed</p>
<p>The libraries' license allows their integration into both open-source and closed-source solutions.These users can leverage lwk to:</p>
<ul>
<li>Develop wallets and online services for asset management,</li>
<li>Create swap services,</li>
<li>Issue, reissue, and burn assets.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="lwk-history"><a class="header" href="#lwk-history">LWK History</a></h1>
<p>BEWallet was <a href="https://github.com/LeoComandini/BEWallet/">originally</a>
an Elements/Liquid wallet library written in Rust to develop
prototypes and experiments.</p>
<p>BEWallet was based on <a href="https://github.com/Blockstream/gdk">Blockstream's GDK</a>.
Essentially some GDK Rust pieces were moved to this project.</p>
<p>This was used as the starting point for the Liquid Wallet Kit project.
Parts that were not necessary have been dropped,
many things have been polished, and new features have been added.</p>
<p>The codebase has been entirely re-written, and now it has
almost no similarity with the original code.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="mermaid.min.js"></script>
        <script src="mermaid-init.js"></script>
        <script src="tabs.js"></script>

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>


    </div>
    </body>
</html>
